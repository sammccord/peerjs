{"version":3,"file":"peerjs.modern.js","sources":["../lib/supports.ts","../lib/util.ts","../lib/logger.ts","../lib/enums.ts","../lib/socket.ts","../lib/negotiator.ts","../lib/baseconnection.ts","../lib/mediaconnection.ts","../lib/encodingQueue.ts","../lib/dataconnection.ts","../lib/api.ts","../lib/peer.ts","../lib/exports.ts"],"sourcesContent":["import { webRTCAdapter } from './adapter';\n\nexport const Supports = new class {\n  readonly isIOS = ['iPad', 'iPhone', 'iPod'].includes(navigator.platform);\n  readonly supportedBrowsers = ['firefox', 'chrome', 'safari'];\n\n  readonly minFirefoxVersion = 59;\n  readonly minChromeVersion = 72;\n  readonly minSafariVersion = 605;\n\n  isWebRTCSupported(): boolean {\n    return typeof RTCPeerConnection !== 'undefined';\n  };\n\n  isBrowserSupported(): boolean {\n    const browser = this.getBrowser();\n    const version = this.getVersion();\n\n    const validBrowser = this.supportedBrowsers.includes(browser);\n\n    if (!validBrowser) return false;\n\n    if (browser === 'chrome') return version >= this.minChromeVersion;\n    if (browser === 'firefox') return version >= this.minFirefoxVersion;\n    if (browser === 'safari') return !this.isIOS && version >= this.minSafariVersion;\n\n    return false;\n  }\n\n  getBrowser(): string {\n    return webRTCAdapter.browserDetails.browser;\n  }\n\n  getVersion(): number {\n    return webRTCAdapter.browserDetails.version || 0;\n  }\n\n  isUnifiedPlanSupported(): boolean {\n    const browser = this.getBrowser();\n    const version = webRTCAdapter.browserDetails.version || 0;\n\n    if (browser === 'chrome' && version < 72) return false;\n    if (browser === 'firefox' && version >= 59) return true;\n    if (!window.RTCRtpTransceiver || !('currentDirection' in RTCRtpTransceiver.prototype)) return false;\n\n    let tempPc: RTCPeerConnection;\n    let supported = false;\n\n    try {\n      tempPc = new RTCPeerConnection();\n      tempPc.addTransceiver('audio');\n      supported = true;\n    } catch (e) { }\n    finally {\n      if (tempPc) {\n        tempPc.close();\n      }\n    }\n\n    return supported;\n  }\n\n  toString(): string {\n    return `Supports: \n    browser:${this.getBrowser()} \n    version:${this.getVersion()} \n    isIOS:${this.isIOS} \n    isWebRTCSupported:${this.isWebRTCSupported()} \n    isBrowserSupported:${this.isBrowserSupported()} \n    isUnifiedPlanSupported:${this.isUnifiedPlanSupported()}`;\n  }\n}","import * as BinaryPack from \"peerjs-js-binarypack\";\nimport { Supports } from \"./supports\";\nimport { UtilSupportsObj } from \"..\";\n\nconst DEFAULT_CONFIG = {\n  iceServers: [\n    { urls: \"stun:stun.l.google.com:19302\" },\n    {\n      urls: \"turn:0.peerjs.com:3478\",\n      username: \"peerjs\",\n      credential: \"peerjsp\",\n    },\n  ],\n  sdpSemantics: \"unified-plan\",\n};\n\nexport const util = new (class {\n  noop(): void {}\n\n  readonly CLOUD_HOST = \"0.peerjs.com\";\n  readonly CLOUD_PORT = 443;\n\n  // Browsers that need chunking:\n  readonly chunkedBrowsers = { Chrome: 1, chrome: 1 };\n  readonly chunkedMTU = 16300; // The original 60000 bytes setting does not work when sending data from Firefox to Chrome, which is \"cut off\" after 16384 bytes and delivered individually.\n\n  // Returns browser-agnostic default config\n  readonly defaultConfig = DEFAULT_CONFIG;\n\n  readonly browser = Supports.getBrowser();\n  readonly browserVersion = Supports.getVersion();\n\n  // Lists which features are supported\n  readonly supports = (function () {\n    const supported: UtilSupportsObj = {\n      browser: Supports.isBrowserSupported(),\n      webRTC: Supports.isWebRTCSupported(),\n      audioVideo: false,\n      data: false,\n      binaryBlob: false,\n      reliable: false,\n    };\n\n    if (!supported.webRTC) return supported;\n\n    let pc: RTCPeerConnection;\n\n    try {\n      pc = new RTCPeerConnection(DEFAULT_CONFIG);\n\n      supported.audioVideo = true;\n\n      let dc: RTCDataChannel;\n\n      try {\n        dc = pc.createDataChannel(\"_PEERJSTEST\", { ordered: true });\n        supported.data = true;\n        supported.reliable = !!dc.ordered;\n\n        // Binary test\n        try {\n          dc.binaryType = \"blob\";\n          supported.binaryBlob = !Supports.isIOS;\n        } catch (e) {}\n      } catch (e) {\n      } finally {\n        if (dc) {\n          dc.close();\n        }\n      }\n    } catch (e) {\n    } finally {\n      if (pc) {\n        pc.close();\n      }\n    }\n\n    return supported;\n  })();\n\n  // Ensure alphanumeric ids\n  validateId(id: string): boolean {\n    // Allow empty ids\n    return !id || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.test(id);\n  }\n\n  pack = BinaryPack.pack;\n  unpack = BinaryPack.unpack;\n\n  // Binary stuff\n\n  _dataCount: number = 1;\n\n  chunk(\n    blob: Blob\n  ): { __peerData: number; n: number; total: number; data: Blob }[] {\n    const chunks = [];\n    const size = blob.size;\n    const total = Math.ceil(size / util.chunkedMTU);\n\n    let index = 0;\n    let start = 0;\n\n    while (start < size) {\n      const end = Math.min(size, start + util.chunkedMTU);\n      const b = blob.slice(start, end);\n\n      const chunk = {\n        __peerData: this._dataCount,\n        n: index,\n        data: b,\n        total,\n      };\n\n      chunks.push(chunk);\n\n      start = end;\n      index++;\n    }\n\n    this._dataCount++;\n\n    return chunks;\n  }\n\n  blobToArrayBuffer(\n    blob: Blob,\n    cb: (arg: ArrayBuffer | null) => void\n  ): FileReader {\n    const fr = new FileReader();\n\n    fr.onload = function (evt) {\n      if (evt.target) {\n        cb(evt.target.result as ArrayBuffer);\n      }\n    };\n\n    fr.readAsArrayBuffer(blob);\n\n    return fr;\n  }\n\n  binaryStringToArrayBuffer(binary: string): ArrayBuffer | SharedArrayBuffer {\n    const byteArray = new Uint8Array(binary.length);\n\n    for (let i = 0; i < binary.length; i++) {\n      byteArray[i] = binary.charCodeAt(i) & 0xff;\n    }\n\n    return byteArray.buffer;\n  }\n\n  randomToken(): string {\n    return Math.random().toString(36).substr(2);\n  }\n\n  isSecure(): boolean {\n    return location.protocol === \"https:\";\n  }\n})();\n","const LOG_PREFIX = 'PeerJS: ';\n\n/*\nPrints log messages depending on the debug level passed in. Defaults to 0.\n0  Prints no logs.\n1  Prints only errors.\n2  Prints errors and warnings.\n3  Prints all logs.\n*/\nexport enum LogLevel {\n    Disabled,\n    Errors,\n    Warnings,\n    All\n}\n\nclass Logger {\n    private _logLevel = LogLevel.Disabled;\n\n    get logLevel(): LogLevel { return this._logLevel; }\n\n    set logLevel(logLevel: LogLevel) { this._logLevel = logLevel; }\n\n    log(...args: any[]) {\n        if (this._logLevel >= LogLevel.All) {\n            this._print(LogLevel.All, ...args);\n        }\n    }\n\n    warn(...args: any[]) {\n        if (this._logLevel >= LogLevel.Warnings) {\n            this._print(LogLevel.Warnings, ...args);\n        }\n    }\n\n    error(...args: any[]) {\n        if (this._logLevel >= LogLevel.Errors) {\n            this._print(LogLevel.Errors, ...args);\n        }\n    }\n\n    setLogFunction(fn: (logLevel: LogLevel, ..._: any[]) => void): void {\n        this._print = fn;\n    }\n\n    private _print(logLevel: LogLevel, ...rest: any[]): void {\n        const copy = [LOG_PREFIX, ...rest];\n\n        for (let i in copy) {\n            if (copy[i] instanceof Error) {\n                copy[i] = \"(\" + copy[i].name + \") \" + copy[i].message;\n\n            }\n        }\n\n        if (logLevel >= LogLevel.All) {\n            console.log(...copy);\n        } else if (logLevel >= LogLevel.Warnings) {\n            console.warn(\"WARNING\", ...copy);\n        } else if (logLevel >= LogLevel.Errors) {\n            console.error(\"ERROR\", ...copy);\n        }\n    }\n}\n\nexport default new Logger();","export enum ConnectionEventType {\n  Open = \"open\",\n  Stream = \"stream\",\n  Data = \"data\",\n  Close = \"close\",\n  Error = \"error\",\n  IceStateChanged = \"iceStateChanged\"\n}\n\nexport enum ConnectionType {\n  Data = \"data\",\n  Media = \"media\"\n}\n\nexport enum PeerEventType {\n  Open = \"open\",\n  Close = \"close\",\n  Connection = \"connection\",\n  Call = \"call\",\n  Disconnected = \"disconnected\",\n  Error = \"error\"\n}\n\nexport enum PeerErrorType {\n  BrowserIncompatible = \"browser-incompatible\",\n  Disconnected = \"disconnected\",\n  InvalidID = \"invalid-id\",\n  InvalidKey = \"invalid-key\",\n  Network = \"network\",\n  PeerUnavailable = \"peer-unavailable\",\n  SslUnavailable = \"ssl-unavailable\",\n  ServerError = \"server-error\",\n  SocketError = \"socket-error\",\n  SocketClosed = \"socket-closed\",\n  UnavailableID = \"unavailable-id\",\n  WebRTC = \"webrtc\"\n}\n\nexport enum SerializationType {\n  Binary = \"binary\",\n  BinaryUTF8 = \"binary-utf8\",\n  JSON = \"json\"\n}\n\nexport enum SocketEventType {\n  Message = \"message\",\n  Disconnected = \"disconnected\",\n  Error = \"error\",\n  Close = \"close\"\n}\n\nexport enum ServerMessageType {\n  Heartbeat = \"HEARTBEAT\",\n  Candidate = \"CANDIDATE\",\n  Offer = \"OFFER\",\n  Answer = \"ANSWER\",\n  Open = \"OPEN\", // The connection to the server is open.\n  Error = \"ERROR\", // Server error.\n  IdTaken = \"ID-TAKEN\", // The selected ID is taken.\n  InvalidKey = \"INVALID-KEY\", // The given API key cannot be found.\n  Leave = \"LEAVE\", // Another peer has closed its connection to this peer.\n  Expire = \"EXPIRE\" // The offer sent to a peer has expired without response.\n\n}","import { EventEmitter } from \"eventemitter3\";\nimport logger from \"./logger\";\nimport { SocketEventType, ServerMessageType } from \"./enums\";\n\n/**\n * An abstraction on top of WebSockets to provide fastest\n * possible connection for peers.\n */\nexport class Socket extends EventEmitter {\n  private _disconnected: boolean = true;\n  private _id?: string;\n  private _messagesQueue: Array<object> = [];\n  private _socket?: WebSocket;\n  private _wsPingTimer?: any;\n  private readonly _baseUrl: string;\n\n  constructor(\n    secure: any,\n    host: string,\n    port: number,\n    path: string,\n    key: string,\n    private readonly pingInterval: number = 5000,\n  ) {\n    super();\n\n    const wsProtocol = secure ? \"wss://\" : \"ws://\";\n\n    this._baseUrl = wsProtocol + host + \":\" + port + path + \"peerjs?key=\" + key;\n  }\n\n  start(id: string, token: string): void {\n    this._id = id;\n\n    const wsUrl = `${this._baseUrl}&id=${id}&token=${token}`;\n\n    if (!!this._socket || !this._disconnected) {\n      return;\n    }\n\n    this._socket = new WebSocket(wsUrl);\n    this._disconnected = false;\n\n    this._socket.onmessage = (event) => {\n      let data;\n\n      try {\n        data = JSON.parse(event.data);\n        logger.log(\"Server message received:\", data);\n      } catch (e) {\n        logger.log(\"Invalid server message\", event.data);\n        return;\n      }\n\n      this.emit(SocketEventType.Message, data);\n    };\n\n    this._socket.onclose = (event) => {\n      if (this._disconnected) {\n        return;\n      }\n\n      logger.log(\"Socket closed.\", event);\n\n      this._cleanup();\n      this._disconnected = true;\n\n      this.emit(SocketEventType.Disconnected);\n    };\n\n    // Take care of the queue of connections if necessary and make sure Peer knows\n    // socket is open.\n    this._socket.onopen = () => {\n      if (this._disconnected) {\n        return;\n      }\n\n      this._sendQueuedMessages();\n\n      logger.log(\"Socket open\");\n\n      this._scheduleHeartbeat();\n    };\n  }\n\n  private _scheduleHeartbeat(): void {\n    this._wsPingTimer = setTimeout(() => {\n      this._sendHeartbeat();\n    }, this.pingInterval);\n  }\n\n  private _sendHeartbeat(): void {\n    if (!this._wsOpen()) {\n      logger.log(`Cannot send heartbeat, because socket closed`);\n      return;\n    }\n\n    const message = JSON.stringify({ type: ServerMessageType.Heartbeat });\n\n    this._socket!.send(message);\n\n    this._scheduleHeartbeat();\n  }\n\n  /** Is the websocket currently open? */\n  private _wsOpen(): boolean {\n    return !!this._socket && this._socket.readyState === 1;\n  }\n\n  /** Send queued messages. */\n  private _sendQueuedMessages(): void {\n    //Create copy of queue and clear it,\n    //because send method push the message back to queue if smth will go wrong\n    const copiedQueue = [...this._messagesQueue];\n    this._messagesQueue = [];\n\n    for (const message of copiedQueue) {\n      this.send(message);\n    }\n  }\n\n  /** Exposed send for DC & Peer. */\n  send(data: any): void {\n    if (this._disconnected) {\n      return;\n    }\n\n    // If we didn't get an ID yet, we can't yet send anything so we should queue\n    // up these messages.\n    if (!this._id) {\n      this._messagesQueue.push(data);\n      return;\n    }\n\n    if (!data.type) {\n      this.emit(SocketEventType.Error, \"Invalid message\");\n      return;\n    }\n\n    if (!this._wsOpen()) {\n      return;\n    }\n\n    const message = JSON.stringify(data);\n\n    this._socket!.send(message);\n  }\n\n  close(): void {\n    if (this._disconnected) {\n      return;\n    }\n\n    this._cleanup();\n\n    this._disconnected = true;\n  }\n\n  private _cleanup(): void {\n    if (!!this._socket) {\n      this._socket.onopen = this._socket.onmessage = this._socket.onclose = null;\n      this._socket.close();\n      this._socket = undefined;\n    }\n\n    clearTimeout(this._wsPingTimer!);\n  }\n}\n","import { util } from \"./util\";\nimport logger from \"./logger\";\nimport { MediaConnection } from \"./mediaconnection\";\nimport { DataConnection } from \"./dataconnection\";\nimport { ConnectionType, PeerErrorType, ConnectionEventType, ServerMessageType } from \"./enums\";\nimport { BaseConnection } from \"./baseconnection\";\n\n/**\n * Manages all negotiations between Peers.\n */\nexport class Negotiator {\n  constructor(readonly connection: BaseConnection) { }\n\n  /** Returns a PeerConnection object set up correctly (for data, media). */\n  startConnection(options: any) {\n    const peerConnection = this._startPeerConnection();\n\n    // Set the connection's PC.\n    this.connection.peerConnection = peerConnection;\n\n    if (this.connection.type === ConnectionType.Media && options._stream) {\n      this._addTracksToConnection(options._stream, peerConnection);\n    }\n\n    // What do we need to do now?\n    if (options.originator) {\n      if (this.connection.type === ConnectionType.Data) {\n        const dataConnection = <DataConnection>this.connection;\n\n        const config: RTCDataChannelInit = { ordered: !!options.reliable };\n\n        const dataChannel = peerConnection.createDataChannel(\n          dataConnection.label,\n          config\n        );\n        dataConnection.initialize(dataChannel);\n      }\n\n      this._makeOffer();\n    } else {\n      this.handleSDP(\"OFFER\", options.sdp);\n    }\n  }\n\n  /** Start a PC. */\n  private _startPeerConnection(): RTCPeerConnection {\n    logger.log(\"Creating RTCPeerConnection.\");\n\n    const peerConnection = new RTCPeerConnection(this.connection.provider.options.config);\n\n    this._setupListeners(peerConnection);\n\n    return peerConnection;\n  }\n\n  /** Set up various WebRTC listeners. */\n  private _setupListeners(\n    peerConnection: RTCPeerConnection\n  ) {\n    const peerId = this.connection.peer;\n    const connectionId = this.connection.connectionId;\n    const connectionType = this.connection.type;\n    const provider = this.connection.provider;\n\n    // ICE CANDIDATES.\n    logger.log(\"Listening for ICE candidates.\");\n\n    peerConnection.onicecandidate = (evt) => {\n      if (!evt.candidate || !evt.candidate.candidate) return;\n\n      logger.log(`Received ICE candidates for ${peerId}:`, evt.candidate);\n\n      provider.socket.send({\n        type: ServerMessageType.Candidate,\n        payload: {\n          candidate: evt.candidate,\n          type: connectionType,\n          connectionId: connectionId\n        },\n        dst: peerId\n      });\n    };\n\n    peerConnection.oniceconnectionstatechange = () => {\n      switch (peerConnection.iceConnectionState) {\n        case \"failed\":\n          logger.log(\n            \"iceConnectionState is failed, closing connections to \" +\n            peerId\n          );\n          this.connection.emit(\n            ConnectionEventType.Error,\n            new Error(\"Negotiation of connection to \" + peerId + \" failed.\")\n          );\n          this.connection.close();\n          break;\n        case \"closed\":\n          logger.log(\n            \"iceConnectionState is closed, closing connections to \" +\n            peerId\n          );\n          this.connection.emit(\n            ConnectionEventType.Error,\n            new Error(\"Connection to \" + peerId + \" closed.\")\n          );\n          this.connection.close();\n          break;\n        case \"disconnected\":\n          logger.log(\n            \"iceConnectionState changed to disconnected on the connection with \" +\n            peerId\n          );\n          break;\n        case \"completed\":\n          peerConnection.onicecandidate = util.noop;\n          break;\n      }\n\n      this.connection.emit(ConnectionEventType.IceStateChanged, peerConnection.iceConnectionState);\n    };\n\n    // DATACONNECTION.\n    logger.log(\"Listening for data channel\");\n    // Fired between offer and answer, so options should already be saved\n    // in the options hash.\n    peerConnection.ondatachannel = (evt) => {\n      logger.log(\"Received data channel\");\n\n      const dataChannel = evt.channel;\n      const connection = <DataConnection>(\n        provider.getConnection(peerId, connectionId)\n      );\n\n      connection.initialize(dataChannel);\n    };\n\n    // MEDIACONNECTION.\n    logger.log(\"Listening for remote stream\");\n\n    peerConnection.ontrack = (evt) => {\n      logger.log(\"Received remote stream\");\n\n      const stream = evt.streams[0];\n      const connection = provider.getConnection(peerId, connectionId);\n\n      if (connection.type === ConnectionType.Media) {\n        const mediaConnection = <MediaConnection>connection;\n\n        this._addStreamToMediaConnection(stream, mediaConnection);\n      }\n    };\n  }\n\n  cleanup(): void {\n    logger.log(\"Cleaning up PeerConnection to \" + this.connection.peer);\n\n    const peerConnection = this.connection.peerConnection;\n\n    if (!peerConnection) {\n      return;\n    }\n\n    this.connection.peerConnection = null;\n\n    //unsubscribe from all PeerConnection's events\n    peerConnection.onicecandidate = peerConnection.oniceconnectionstatechange = peerConnection.ondatachannel = peerConnection.ontrack = () => { };\n\n    const peerConnectionNotClosed = peerConnection.signalingState !== \"closed\";\n    let dataChannelNotClosed = false;\n\n    if (this.connection.type === ConnectionType.Data) {\n      const dataConnection = <DataConnection>this.connection;\n      const dataChannel = dataConnection.dataChannel;\n\n      if (dataChannel) {\n        dataChannelNotClosed = !!dataChannel.readyState && dataChannel.readyState !== \"closed\";\n      }\n    }\n\n    if (peerConnectionNotClosed || dataChannelNotClosed) {\n      peerConnection.close();\n    }\n  }\n\n  private async _makeOffer(): Promise<void> {\n    const peerConnection = this.connection.peerConnection;\n    const provider = this.connection.provider;\n\n    try {\n      const offer = await peerConnection.createOffer(\n        this.connection.options.constraints\n      );\n\n      logger.log(\"Created offer.\");\n\n      if (this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform === 'function') {\n        offer.sdp = this.connection.options.sdpTransform(offer.sdp) || offer.sdp;\n      }\n\n      try {\n        await peerConnection.setLocalDescription(offer);\n\n        logger.log(\"Set localDescription:\", offer, `for:${this.connection.peer}`);\n\n        let payload: any = {\n          sdp: offer,\n          type: this.connection.type,\n          connectionId: this.connection.connectionId,\n          metadata: this.connection.metadata,\n          browser: util.browser\n        };\n\n        if (this.connection.type === ConnectionType.Data) {\n          const dataConnection = <DataConnection>this.connection;\n\n          payload = {\n            ...payload,\n            label: dataConnection.label,\n            reliable: dataConnection.reliable,\n            serialization: dataConnection.serialization\n          };\n        }\n\n        provider.socket.send({\n          type: ServerMessageType.Offer,\n          payload,\n          dst: this.connection.peer\n        });\n      } catch (err) {\n        // TODO: investigate why _makeOffer is being called from the answer\n        if (\n          err !=\n          \"OperationError: Failed to set local offer sdp: Called in wrong state: kHaveRemoteOffer\"\n        ) {\n          provider.emitError(PeerErrorType.WebRTC, err);\n          logger.log(\"Failed to setLocalDescription, \", err);\n        }\n      }\n    } catch (err_1) {\n      provider.emitError(PeerErrorType.WebRTC, err_1);\n      logger.log(\"Failed to createOffer, \", err_1);\n    }\n  }\n\n  private async _makeAnswer(): Promise<void> {\n    const peerConnection = this.connection.peerConnection;\n    const provider = this.connection.provider;\n\n    try {\n      const answer = await peerConnection.createAnswer();\n      logger.log(\"Created answer.\");\n\n      if (this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform === 'function') {\n        answer.sdp = this.connection.options.sdpTransform(answer.sdp) || answer.sdp;\n      }\n\n      try {\n        await peerConnection.setLocalDescription(answer);\n\n        logger.log(`Set localDescription:`, answer, `for:${this.connection.peer}`);\n\n        provider.socket.send({\n          type: ServerMessageType.Answer,\n          payload: {\n            sdp: answer,\n            type: this.connection.type,\n            connectionId: this.connection.connectionId,\n            browser: util.browser\n          },\n          dst: this.connection.peer\n        });\n      } catch (err) {\n        provider.emitError(PeerErrorType.WebRTC, err);\n        logger.log(\"Failed to setLocalDescription, \", err);\n      }\n    } catch (err_1) {\n      provider.emitError(PeerErrorType.WebRTC, err_1);\n      logger.log(\"Failed to create answer, \", err_1);\n    }\n  }\n\n  /** Handle an SDP. */\n  async handleSDP(\n    type: string,\n    sdp: any\n  ): Promise<void> {\n    sdp = new RTCSessionDescription(sdp);\n    const peerConnection = this.connection.peerConnection;\n    const provider = this.connection.provider;\n\n    logger.log(\"Setting remote description\", sdp);\n\n    const self = this;\n\n    try {\n      await peerConnection.setRemoteDescription(sdp);\n      logger.log(`Set remoteDescription:${type} for:${this.connection.peer}`);\n      if (type === \"OFFER\") {\n        await self._makeAnswer();\n      }\n    } catch (err) {\n      provider.emitError(PeerErrorType.WebRTC, err);\n      logger.log(\"Failed to setRemoteDescription, \", err);\n    }\n  }\n\n  /** Handle a candidate. */\n  async handleCandidate(ice: any): Promise<void> {\n    logger.log(`handleCandidate:`, ice);\n\n    const candidate = ice.candidate;\n    const sdpMLineIndex = ice.sdpMLineIndex;\n    const sdpMid = ice.sdpMid;\n    const peerConnection = this.connection.peerConnection;\n    const provider = this.connection.provider;\n\n    try {\n      await peerConnection.addIceCandidate(\n        new RTCIceCandidate({\n          sdpMid: sdpMid,\n          sdpMLineIndex: sdpMLineIndex,\n          candidate: candidate\n        })\n      );\n      logger.log(`Added ICE candidate for:${this.connection.peer}`);\n    } catch (err) {\n      provider.emitError(PeerErrorType.WebRTC, err);\n      logger.log(\"Failed to handleCandidate, \", err);\n    }\n  }\n\n  private _addTracksToConnection(\n    stream: MediaStream,\n    peerConnection: RTCPeerConnection\n  ): void {\n    logger.log(`add tracks from stream ${stream.id} to peer connection`);\n\n    if (!peerConnection.addTrack) {\n      return logger.error(\n        `Your browser does't support RTCPeerConnection#addTrack. Ignored.`\n      );\n    }\n\n    stream.getTracks().forEach(track => {\n      peerConnection.addTrack(track, stream);\n    });\n  }\n\n  private _addStreamToMediaConnection(\n    stream: MediaStream,\n    mediaConnection: MediaConnection\n  ): void {\n    logger.log(\n      `add stream ${stream.id} to media connection ${\n      mediaConnection.connectionId\n      }`\n    );\n\n    mediaConnection.addStream(stream);\n  }\n}\n","import { EventEmitter } from \"eventemitter3\";\nimport { Peer } from \"./peer\";\nimport { ServerMessage } from \"./servermessage\";\nimport { ConnectionType } from \"./enums\";\n\nexport abstract class BaseConnection extends EventEmitter {\n  protected _open = false;\n\n  readonly metadata: any;\n  connectionId: string;\n\n  peerConnection: RTCPeerConnection;\n\n  abstract get type(): ConnectionType;\n\n  get open() {\n    return this._open;\n  }\n\n  constructor(\n    readonly peer: string,\n    public provider: Peer,\n    readonly options: any\n  ) {\n    super();\n\n    this.metadata = options.metadata;\n  }\n\n  abstract close(): void;\n\n  abstract handleMessage(message: ServerMessage): void;\n}\n","import { util } from \"./util\";\nimport logger from \"./logger\";\nimport { Negotiator } from \"./negotiator\";\nimport { ConnectionType, ConnectionEventType, ServerMessageType } from \"./enums\";\nimport { Peer } from \"./peer\";\nimport { BaseConnection } from \"./baseconnection\";\nimport { ServerMessage } from \"./servermessage\";\nimport { AnswerOption } from \"..\";\n\n/**\n * Wraps the streaming interface between two Peers.\n */\nexport class MediaConnection extends BaseConnection {\n  private static readonly ID_PREFIX = \"mc_\";\n\n  private _negotiator: Negotiator;\n  private _localStream: MediaStream;\n  private _remoteStream: MediaStream;\n\n  get type() {\n    return ConnectionType.Media;\n  }\n\n  get localStream(): MediaStream { return this._localStream; }\n  get remoteStream(): MediaStream { return this._remoteStream; }\n\n  constructor(peerId: string, provider: Peer, options: any) {\n    super(peerId, provider, options);\n\n    this._localStream = this.options._stream;\n    this.connectionId =\n      this.options.connectionId ||\n      MediaConnection.ID_PREFIX + util.randomToken();\n\n    this._negotiator = new Negotiator(this);\n\n    if (this._localStream) {\n      this._negotiator.startConnection({\n        _stream: this._localStream,\n        originator: true\n      });\n    }\n  }\n\n  addStream(remoteStream) {\n    logger.log(\"Receiving stream\", remoteStream);\n\n    this._remoteStream = remoteStream;\n    super.emit(ConnectionEventType.Stream, remoteStream); // Should we call this `open`?\n  }\n\n  handleMessage(message: ServerMessage): void {\n    const type = message.type;\n    const payload = message.payload;\n\n    switch (message.type) {\n      case ServerMessageType.Answer:\n        // Forward to negotiator\n        this._negotiator.handleSDP(type, payload.sdp);\n        this._open = true;\n        break;\n      case ServerMessageType.Candidate:\n        this._negotiator.handleCandidate(payload.candidate);\n        break;\n      default:\n        logger.warn(`Unrecognized message type:${type} from peer:${this.peer}`);\n        break;\n    }\n  }\n\n  answer(stream: MediaStream, options: AnswerOption = {}): void {\n    if (this._localStream) {\n      logger.warn(\n        \"Local stream already exists on this MediaConnection. Are you answering a call twice?\"\n      );\n      return;\n    }\n\n    this._localStream = stream;\n\n    if (options && options.sdpTransform) {\n      this.options.sdpTransform = options.sdpTransform;\n    }\n\n    this._negotiator.startConnection({ ...this.options._payload, _stream: stream });\n    // Retrieve lost messages stored because PeerConnection not set up.\n    const messages = this.provider._getMessages(this.connectionId);\n\n    for (let message of messages) {\n      this.handleMessage(message);\n    }\n\n    this._open = true;\n  }\n\n  /**\n   * Exposed functionality for users.\n   */\n\n  /** Allows user to close connection. */\n  close(): void {\n    if (this._negotiator) {\n      this._negotiator.cleanup();\n      this._negotiator = null;\n    }\n\n    this._localStream = null;\n    this._remoteStream = null;\n\n    if (this.provider) {\n      this.provider._removeConnection(this);\n\n      this.provider = null;\n    }\n\n    if (this.options && this.options._stream) {\n      this.options._stream = null;\n    }\n\n    if (!this.open) {\n      return;\n    }\n\n    this._open = false;\n\n    super.emit(ConnectionEventType.Close);\n  }\n}\n","import { EventEmitter } from \"eventemitter3\";\nimport logger from \"./logger\";\n\nexport class EncodingQueue extends EventEmitter {\n  readonly fileReader: FileReader = new FileReader();\n\n  private _queue: Blob[] = [];\n  private _processing: boolean = false;\n\n  constructor() {\n    super();\n\n    this.fileReader.onload = (evt) => {\n      this._processing = false;\n\n      if (evt.target) {\n        this.emit('done', evt.target.result as ArrayBuffer);\n      }\n\n      this.doNextTask();\n    };\n\n    this.fileReader.onerror = (evt) => {\n      logger.error(`EncodingQueue error:`, evt);\n      this._processing = false;\n      this.destroy();\n      this.emit('error', evt);\n    }\n  }\n\n  get queue(): Blob[] {\n    return this._queue;\n  }\n\n  get size(): number {\n    return this.queue.length;\n  }\n\n  get processing(): boolean {\n    return this._processing;\n  }\n\n  enque(blob: Blob): void {\n    this.queue.push(blob);\n\n    if (this.processing) return;\n\n    this.doNextTask();\n  }\n\n  destroy(): void {\n    this.fileReader.abort();\n    this._queue = [];\n  }\n\n  private doNextTask(): void {\n    if (this.size === 0) return;\n    if (this.processing) return;\n\n    this._processing = true;\n\n    this.fileReader.readAsArrayBuffer(this.queue.shift());\n  }\n}","import { util } from \"./util\";\nimport logger from \"./logger\";\nimport { Negotiator } from \"./negotiator\";\nimport {\n  ConnectionType,\n  ConnectionEventType,\n  SerializationType,\n  ServerMessageType\n} from \"./enums\";\nimport { Peer } from \"./peer\";\nimport { BaseConnection } from \"./baseconnection\";\nimport { ServerMessage } from \"./servermessage\";\nimport { EncodingQueue } from './encodingQueue';\nimport { DataConnection as IDataConnection } from '../index';\n\n/**\n * Wraps a DataChannel between two Peers.\n */\nexport class DataConnection extends BaseConnection implements IDataConnection {\n  private static readonly ID_PREFIX = \"dc_\";\n  private static readonly MAX_BUFFERED_AMOUNT = 8 * 1024 * 1024;\n\n  private _negotiator: Negotiator;\n  readonly label: string;\n  readonly serialization: SerializationType;\n  readonly reliable: boolean;\n  stringify: (data: any) => string = JSON.stringify;\n  parse: (data: string) => any = JSON.parse;\n\n  get type() {\n    return ConnectionType.Data;\n  }\n\n  private _buffer: any[] = [];\n  private _bufferSize = 0;\n  private _buffering = false;\n  private _chunkedData: {\n    [id: number]: {\n      data: Blob[],\n      count: number,\n      total: number\n    }\n  } = {};\n\n  private _dc: RTCDataChannel;\n  private _encodingQueue = new EncodingQueue();\n\n  get dataChannel(): RTCDataChannel {\n    return this._dc;\n  }\n\n  get bufferSize(): number { return this._bufferSize; }\n\n  constructor(peerId: string, provider: Peer, options: any) {\n    super(peerId, provider, options);\n\n    this.connectionId =\n      this.options.connectionId || DataConnection.ID_PREFIX + util.randomToken();\n\n    this.label = this.options.label || this.connectionId;\n    this.serialization = this.options.serialization || SerializationType.Binary;\n    this.reliable = !!this.options.reliable;\n\n    this._encodingQueue.on('done', (ab: ArrayBuffer) => {\n      this._bufferedSend(ab);\n    });\n\n    this._encodingQueue.on('error', () => {\n      logger.error(`DC#${this.connectionId}: Error occured in encoding from blob to arraybuffer, close DC`);\n      this.close();\n    });\n\n    this._negotiator = new Negotiator(this);\n\n    this._negotiator.startConnection(\n      this.options._payload || {\n        originator: true\n      }\n    );\n  }\n\n  /** Called by the Negotiator when the DataChannel is ready. */\n  initialize(dc: RTCDataChannel): void {\n    this._dc = dc;\n    this._configureDataChannel();\n  }\n\n  private _configureDataChannel(): void {\n    if (!util.supports.binaryBlob || util.supports.reliable) {\n      this.dataChannel.binaryType = \"arraybuffer\";\n    }\n\n    this.dataChannel.onopen = () => {\n      logger.log(`DC#${this.connectionId} dc connection success`);\n      this._open = true;\n      this.emit(ConnectionEventType.Open);\n    };\n\n    this.dataChannel.onmessage = (e) => {\n      logger.log(`DC#${this.connectionId} dc onmessage:`, e.data);\n      this._handleDataMessage(e);\n    };\n\n    this.dataChannel.onclose = () => {\n      logger.log(`DC#${this.connectionId} dc closed for:`, this.peer);\n      this.close();\n    };\n  }\n\n  // Handles a DataChannel message.\n  private _handleDataMessage({ data }: { data: Blob | ArrayBuffer | string }): void {\n    const datatype = data.constructor;\n\n    const isBinarySerialization = this.serialization === SerializationType.Binary ||\n      this.serialization === SerializationType.BinaryUTF8;\n\n    let deserializedData: any = data;\n\n    if (isBinarySerialization) {\n      if (datatype === Blob) {\n        // Datatype should never be blob\n        util.blobToArrayBuffer(data as Blob, (ab) => {\n          const unpackedData = util.unpack(ab);\n          this.emit(ConnectionEventType.Data, unpackedData);\n        });\n        return;\n      } else if (datatype === ArrayBuffer) {\n        deserializedData = util.unpack(data as ArrayBuffer);\n      } else if (datatype === String) {\n        // String fallback for binary data for browsers that don't support binary yet\n        const ab = util.binaryStringToArrayBuffer(data as string);\n        deserializedData = util.unpack(ab);\n      }\n    } else if (this.serialization === SerializationType.JSON) {\n      deserializedData = this.parse(data as string);\n    }\n\n    // Check if we've chunked--if so, piece things back together.\n    // We're guaranteed that this isn't 0.\n    if (deserializedData.__peerData) {\n      this._handleChunk(deserializedData);\n      return;\n    }\n\n    super.emit(ConnectionEventType.Data, deserializedData);\n  }\n\n  private _handleChunk(data: { __peerData: number, n: number, total: number, data: Blob }): void {\n    const id = data.__peerData;\n    const chunkInfo = this._chunkedData[id] || {\n      data: [],\n      count: 0,\n      total: data.total\n    };\n\n    chunkInfo.data[data.n] = data.data;\n    chunkInfo.count++;\n    this._chunkedData[id] = chunkInfo;\n\n    if (chunkInfo.total === chunkInfo.count) {\n      // Clean up before making the recursive call to `_handleDataMessage`.\n      delete this._chunkedData[id];\n\n      // We've received all the chunks--time to construct the complete data.\n      const data = new Blob(chunkInfo.data);\n      this._handleDataMessage({ data });\n    }\n  }\n\n  /**\n   * Exposed functionality for users.\n   */\n\n  /** Allows user to close connection. */\n  close(): void {\n    this._buffer = [];\n    this._bufferSize = 0;\n    this._chunkedData = {};\n\n    if (this._negotiator) {\n      this._negotiator.cleanup();\n      this._negotiator = null;\n    }\n\n    if (this.provider) {\n      this.provider._removeConnection(this);\n\n      this.provider = null;\n    }\n\n    if (this.dataChannel) {\n      this.dataChannel.onopen = null;\n      this.dataChannel.onmessage = null;\n      this.dataChannel.onclose = null;\n      this._dc = null;\n    }\n\n    if (this._encodingQueue) {\n      this._encodingQueue.destroy();\n      this._encodingQueue.removeAllListeners();\n      this._encodingQueue = null;\n    }\n\n    if (!this.open) {\n      return;\n    }\n\n    this._open = false;\n\n    super.emit(ConnectionEventType.Close);\n  }\n\n  /** Allows user to send data. */\n  send(data: any, chunked?: boolean): void {\n    if (!this.open) {\n      super.emit(\n        ConnectionEventType.Error,\n        new Error(\n          \"Connection is not open. You should listen for the `open` event before sending messages.\"\n        )\n      );\n      return;\n    }\n\n    if (this.serialization === SerializationType.JSON) {\n      this._bufferedSend(this.stringify(data));\n    } else if (\n      this.serialization === SerializationType.Binary ||\n      this.serialization === SerializationType.BinaryUTF8\n    ) {\n      const blob = util.pack(data);\n\n      if (!chunked && blob.size > util.chunkedMTU) {\n        this._sendChunks(blob);\n        return;\n      }\n\n      if (!util.supports.binaryBlob) {\n        // We only do this if we really need to (e.g. blobs are not supported),\n        // because this conversion is costly.\n        this._encodingQueue.enque(blob);\n      } else {\n        this._bufferedSend(blob);\n      }\n    } else {\n      this._bufferedSend(data);\n    }\n  }\n\n  private _bufferedSend(msg: any): void {\n    if (this._buffering || !this._trySend(msg)) {\n      this._buffer.push(msg);\n      this._bufferSize = this._buffer.length;\n    }\n  }\n\n  // Returns true if the send succeeds.\n  private _trySend(msg: any): boolean {\n    if (!this.open) {\n      return false;\n    }\n\n    if (this.dataChannel.bufferedAmount > DataConnection.MAX_BUFFERED_AMOUNT) {\n      this._buffering = true;\n      setTimeout(() => {\n        this._buffering = false;\n        this._tryBuffer();\n      }, 50);\n\n      return false;\n    }\n\n    try {\n      this.dataChannel.send(msg);\n    } catch (e) {\n      logger.error(`DC#:${this.connectionId} Error when sending:`, e);\n      this._buffering = true;\n\n      this.close();\n\n      return false;\n    }\n\n    return true;\n  }\n\n  // Try to send the first message in the buffer.\n  private _tryBuffer(): void {\n    if (!this.open) {\n      return;\n    }\n\n    if (this._buffer.length === 0) {\n      return;\n    }\n\n    const msg = this._buffer[0];\n\n    if (this._trySend(msg)) {\n      this._buffer.shift();\n      this._bufferSize = this._buffer.length;\n      this._tryBuffer();\n    }\n  }\n\n  private _sendChunks(blob: Blob): void {\n    const blobs = util.chunk(blob);\n    logger.log(`DC#${this.connectionId} Try to send ${blobs.length} chunks...`);\n\n    for (let blob of blobs) {\n      this.send(blob, true);\n    }\n  }\n\n  handleMessage(message: ServerMessage): void {\n    const payload = message.payload;\n\n    switch (message.type) {\n      case ServerMessageType.Answer:\n        this._negotiator.handleSDP(message.type, payload.sdp);\n        break;\n      case ServerMessageType.Candidate:\n        this._negotiator.handleCandidate(payload.candidate);\n        break;\n      default:\n        logger.warn(\n          \"Unrecognized message type:\",\n          message.type,\n          \"from peer:\",\n          this.peer\n        );\n        break;\n    }\n  }\n}\n","import { util } from \"./util\";\nimport logger from \"./logger\";\n\nexport class API {\n  constructor(private readonly _options: any) { }\n\n  private _buildUrl(method: string): string {\n    const protocol = this._options.secure ? \"https://\" : \"http://\";\n    let url =\n      protocol +\n      this._options.host +\n      \":\" +\n      this._options.port +\n      this._options.path +\n      this._options.key +\n      \"/\" +\n      method;\n    const queryString = \"?ts=\" + new Date().getTime() + \"\" + Math.random();\n    url += queryString;\n\n    return url;\n  }\n\n  /** Get a unique ID from the server via XHR and initialize with it. */\n  async retrieveId(): Promise<string> {\n    const url = this._buildUrl(\"id\");\n\n    try {\n      const response = await fetch(url);\n\n      if (response.status !== 200) {\n        throw new Error(`Error. Status:${response.status}`);\n      }\n\n      return response.text();\n    } catch (error) {\n      logger.error(\"Error retrieving ID\", error);\n\n      let pathError = \"\";\n\n      if (\n        this._options.path === \"/\" &&\n        this._options.host !== util.CLOUD_HOST\n      ) {\n        pathError =\n          \" If you passed in a `path` to your self-hosted PeerServer, \" +\n          \"you'll also need to pass in that same path when creating a new \" +\n          \"Peer.\";\n      }\n\n      throw new Error(\"Could not get an ID from the server.\" + pathError);\n    }\n  }\n\n  /** @deprecated */\n  async listAllPeers(): Promise<any[]> {\n    const url = this._buildUrl(\"peers\");\n\n    try {\n      const response = await fetch(url);\n\n      if (response.status !== 200) {\n        if (response.status === 401) {\n          let helpfulError = \"\";\n\n          if (this._options.host === util.CLOUD_HOST) {\n            helpfulError =\n              \"It looks like you're using the cloud server. You can email \" +\n              \"team@peerjs.com to enable peer listing for your API key.\";\n          } else {\n            helpfulError =\n              \"You need to enable `allow_discovery` on your self-hosted \" +\n              \"PeerServer to use this feature.\";\n          }\n\n          throw new Error(\"It doesn't look like you have permission to list peers IDs. \" +\n            helpfulError);\n        }\n\n        throw new Error(`Error. Status:${response.status}`);\n      }\n\n      return response.json();\n    } catch (error) {\n      logger.error(\"Error retrieving list peers\", error);\n\n      throw new Error(\"Could not get list peers from the server.\" + error);\n    }\n  }\n}\n","import { EventEmitter } from \"eventemitter3\";\nimport { util } from \"./util\";\nimport logger, { LogLevel } from \"./logger\";\nimport { Socket } from \"./socket\";\nimport { MediaConnection } from \"./mediaconnection\";\nimport { DataConnection } from \"./dataconnection\";\nimport {\n  ConnectionType,\n  PeerErrorType,\n  PeerEventType,\n  SocketEventType,\n  ServerMessageType\n} from \"./enums\";\nimport { BaseConnection } from \"./baseconnection\";\nimport { ServerMessage } from \"./servermessage\";\nimport { API } from \"./api\";\nimport { PeerConnectOption, PeerJSOption } from \"..\";\n\nclass PeerOptions implements PeerJSOption {\n  debug?: LogLevel; // 1: Errors, 2: Warnings, 3: All logs\n  host?: string;\n  port?: number;\n  path?: string;\n  key?: string;\n  token?: string;\n  config?: any;\n  secure?: boolean;\n  pingInterval?: number;\n  logFunction?: (logLevel: LogLevel, ...rest: any[]) => void;\n}\n\n/**\n * A peer who can initiate connections with other peers.\n */\nexport class Peer extends EventEmitter {\n  private static readonly DEFAULT_KEY = \"peerjs\";\n\n  private readonly _options: PeerOptions;\n  private readonly _api: API;\n  private readonly _socket: Socket;\n\n  private _id: string | null = null;\n  private _lastServerId: string | null = null;\n\n  // States.\n  private _destroyed = false; // Connections have been killed\n  private _disconnected = false; // Connection to PeerServer killed but P2P connections still active\n  private _open = false; // Sockets and such are not yet open.\n  private readonly _connections: Map<string, BaseConnection[]> = new Map(); // All connections for this peer.\n  private readonly _lostMessages: Map<string, ServerMessage[]> = new Map(); // src => [list of messages]\n\n  get id() {\n    return this._id;\n  }\n\n  get options() {\n    return this._options;\n  }\n\n  get open() {\n    return this._open;\n  }\n\n  get socket() {\n    return this._socket;\n  }\n\n  /**\n   * @deprecated \n   * Return type will change from Object to Map<string,[]> \n   */\n  get connections(): Object {\n    const plainConnections = Object.create(null);\n\n    for (let [k, v] of this._connections) {\n      plainConnections[k] = v;\n    }\n\n    return plainConnections;\n  }\n\n  get destroyed() {\n    return this._destroyed;\n  }\n  get disconnected() {\n    return this._disconnected;\n  }\n\n  constructor(id?: string | PeerOptions, options?: PeerOptions) {\n    super();\n\n    let userId: string | undefined;\n\n    // Deal with overloading\n    if (id && id.constructor == Object) {\n      options = id as PeerOptions;\n    } else if (id) {\n      userId = id.toString();\n    }\n\n    // Configurize options\n    options = {\n      debug: 0, // 1: Errors, 2: Warnings, 3: All logs\n      host: util.CLOUD_HOST,\n      port: util.CLOUD_PORT,\n      path: \"/\",\n      key: Peer.DEFAULT_KEY,\n      token: util.randomToken(),\n      config: util.defaultConfig,\n      ...options\n    };\n    this._options = options;\n\n    // Detect relative URL host.\n    if (this._options.host === \"/\") {\n      this._options.host = window.location.hostname;\n    }\n\n    // Set path correctly.\n    if (this._options.path) {\n      if (this._options.path[0] !== \"/\") {\n        this._options.path = \"/\" + this._options.path;\n      }\n      if (this._options.path[this._options.path.length - 1] !== \"/\") {\n        this._options.path += \"/\";\n      }\n    }\n\n    // Set whether we use SSL to same as current host\n    if (this._options.secure === undefined && this._options.host !== util.CLOUD_HOST) {\n      this._options.secure = util.isSecure();\n    } else if (this._options.host == util.CLOUD_HOST) {\n      this._options.secure = true;\n    }\n    // Set a custom log function if present\n    if (this._options.logFunction) {\n      logger.setLogFunction(this._options.logFunction);\n    }\n\n    logger.logLevel = this._options.debug || 0;\n\n    this._api = new API(options);\n    this._socket = this._createServerConnection();\n\n    // Sanity checks\n    // Ensure WebRTC supported\n    if (!util.supports.audioVideo && !util.supports.data) {\n      this._delayedAbort(\n        PeerErrorType.BrowserIncompatible,\n        \"The current browser does not support WebRTC\"\n      );\n      return;\n    }\n\n    // Ensure alphanumeric id\n    if (!!userId && !util.validateId(userId)) {\n      this._delayedAbort(PeerErrorType.InvalidID, `ID \"${userId}\" is invalid`);\n      return;\n    }\n\n    if (userId) {\n      this._initialize(userId);\n    } else {\n      this._api.retrieveId()\n        .then(id => this._initialize(id))\n        .catch(error => this._abort(PeerErrorType.ServerError, error));\n    }\n  }\n\n  private _createServerConnection(): Socket {\n    const socket = new Socket(\n      this._options.secure,\n      this._options.host!,\n      this._options.port!,\n      this._options.path!,\n      this._options.key!,\n      this._options.pingInterval\n    );\n\n    socket.on(SocketEventType.Message, (data: ServerMessage) => {\n      this._handleMessage(data);\n    });\n\n    socket.on(SocketEventType.Error, (error: string) => {\n      this._abort(PeerErrorType.SocketError, error);\n    });\n\n    socket.on(SocketEventType.Disconnected, () => {\n      if (this.disconnected) {\n        return;\n      }\n\n      this.emitError(PeerErrorType.Network, \"Lost connection to server.\");\n      this.disconnect();\n    });\n\n    socket.on(SocketEventType.Close, () => {\n      if (this.disconnected) {\n        return;\n      }\n\n      this._abort(PeerErrorType.SocketClosed, \"Underlying socket is already closed.\");\n    });\n\n    return socket;\n  }\n\n  /** Initialize a connection with the server. */\n  private _initialize(id: string): void {\n    this._id = id;\n    this.socket.start(id, this._options.token!);\n  }\n\n  /** Handles messages from the server. */\n  private _handleMessage(message: ServerMessage): void {\n    const type = message.type;\n    const payload = message.payload;\n    const peerId = message.src;\n\n    switch (type) {\n      case ServerMessageType.Open: // The connection to the server is open.\n        this._lastServerId = this.id;\n        this._open = true;\n        this.emit(PeerEventType.Open, this.id);\n        break;\n      case ServerMessageType.Error: // Server error.\n        this._abort(PeerErrorType.ServerError, payload.msg);\n        break;\n      case ServerMessageType.IdTaken: // The selected ID is taken.\n        this._abort(PeerErrorType.UnavailableID, `ID \"${this.id}\" is taken`);\n        break;\n      case ServerMessageType.InvalidKey: // The given API key cannot be found.\n        this._abort(PeerErrorType.InvalidKey, `API KEY \"${this._options.key}\" is invalid`);\n        break;\n      case ServerMessageType.Leave: // Another peer has closed its connection to this peer.\n        logger.log(`Received leave message from ${peerId}`);\n        this._cleanupPeer(peerId);\n        this._connections.delete(peerId);\n        break;\n      case ServerMessageType.Expire: // The offer sent to a peer has expired without response.\n        this.emitError(PeerErrorType.PeerUnavailable, `Could not connect to peer ${peerId}`);\n        break;\n      case ServerMessageType.Offer: {\n        // we should consider switching this to CALL/CONNECT, but this is the least breaking option.\n        const connectionId = payload.connectionId;\n        let connection = this.getConnection(peerId, connectionId);\n\n        if (connection) {\n          connection.close();\n          logger.warn(`Offer received for existing Connection ID:${connectionId}`);\n        }\n\n        // Create a new connection.\n        if (payload.type === ConnectionType.Media) {\n          connection = new MediaConnection(peerId, this, {\n            connectionId: connectionId,\n            _payload: payload,\n            metadata: payload.metadata\n          });\n          this._addConnection(peerId, connection);\n          this.emit(PeerEventType.Call, connection);\n        } else if (payload.type === ConnectionType.Data) {\n          connection = new DataConnection(peerId, this, {\n            connectionId: connectionId,\n            _payload: payload,\n            metadata: payload.metadata,\n            label: payload.label,\n            serialization: payload.serialization,\n            reliable: payload.reliable\n          });\n          this._addConnection(peerId, connection);\n          this.emit(PeerEventType.Connection, connection);\n        } else {\n          logger.warn(`Received malformed connection type:${payload.type}`);\n          return;\n        }\n\n        // Find messages.\n        const messages = this._getMessages(connectionId);\n        for (let message of messages) {\n          connection.handleMessage(message);\n        }\n\n        break;\n      }\n      default: {\n        if (!payload) {\n          logger.warn(`You received a malformed message from ${peerId} of type ${type}`);\n          return;\n        }\n\n        const connectionId = payload.connectionId;\n        const connection = this.getConnection(peerId, connectionId);\n\n        if (connection && connection.peerConnection) {\n          // Pass it on.\n          connection.handleMessage(message);\n        } else if (connectionId) {\n          // Store for possible later use\n          this._storeMessage(connectionId, message);\n        } else {\n          logger.warn(\"You received an unrecognized message:\", message);\n        }\n        break;\n      }\n    }\n  }\n\n  /** Stores messages without a set up connection, to be claimed later. */\n  private _storeMessage(connectionId: string, message: ServerMessage): void {\n    if (!this._lostMessages.has(connectionId)) {\n      this._lostMessages.set(connectionId, []);\n    }\n\n    this._lostMessages.get(connectionId).push(message);\n  }\n\n  /** Retrieve messages from lost message store */\n  //TODO Change it to private\n  public _getMessages(connectionId: string): ServerMessage[] {\n    const messages = this._lostMessages.get(connectionId);\n\n    if (messages) {\n      this._lostMessages.delete(connectionId);\n      return messages;\n    }\n\n    return [];\n  }\n\n  /**\n   * Returns a DataConnection to the specified peer. See documentation for a\n   * complete list of options.\n   */\n  connect(peer: string, options: PeerConnectOption = {}): DataConnection {\n    if (this.disconnected) {\n      logger.warn(\n        \"You cannot connect to a new Peer because you called \" +\n        \".disconnect() on this Peer and ended your connection with the \" +\n        \"server. You can create a new Peer to reconnect, or call reconnect \" +\n        \"on this peer if you believe its ID to still be available.\"\n      );\n      this.emitError(\n        PeerErrorType.Disconnected,\n        \"Cannot connect to new Peer after disconnecting from server.\"\n      );\n      return;\n    }\n\n    const dataConnection = new DataConnection(peer, this, options);\n    this._addConnection(peer, dataConnection);\n    return dataConnection;\n  }\n\n  /**\n   * Returns a MediaConnection to the specified peer. See documentation for a\n   * complete list of options.\n   */\n  call(peer: string, stream: MediaStream, options: any = {}): MediaConnection {\n    if (this.disconnected) {\n      logger.warn(\n        \"You cannot connect to a new Peer because you called \" +\n        \".disconnect() on this Peer and ended your connection with the \" +\n        \"server. You can create a new Peer to reconnect.\"\n      );\n      this.emitError(\n        PeerErrorType.Disconnected,\n        \"Cannot connect to new Peer after disconnecting from server.\"\n      );\n      return;\n    }\n\n    if (!stream) {\n      logger.error(\n        \"To call a peer, you must provide a stream from your browser's `getUserMedia`.\"\n      );\n      return;\n    }\n\n    options._stream = stream;\n\n    const mediaConnection = new MediaConnection(peer, this, options);\n    this._addConnection(peer, mediaConnection);\n    return mediaConnection;\n  }\n\n  /** Add a data/media connection to this peer. */\n  private _addConnection(peerId: string, connection: BaseConnection): void {\n    logger.log(`add connection ${connection.type}:${connection.connectionId} to peerId:${peerId}`);\n\n    if (!this._connections.has(peerId)) {\n      this._connections.set(peerId, []);\n    }\n    this._connections.get(peerId).push(connection);\n  }\n\n  //TODO should be private\n  _removeConnection(connection: BaseConnection): void {\n    const connections = this._connections.get(connection.peer);\n\n    if (connections) {\n      const index = connections.indexOf(connection);\n\n      if (index !== -1) {\n        connections.splice(index, 1);\n      }\n    }\n\n    //remove from lost messages\n    this._lostMessages.delete(connection.connectionId);\n  }\n\n  /** Retrieve a data/media connection for this peer. */\n  getConnection(peerId: string, connectionId: string): null | BaseConnection {\n    const connections = this._connections.get(peerId);\n    if (!connections) {\n      return null;\n    }\n\n    for (let connection of connections) {\n      if (connection.connectionId === connectionId) {\n        return connection;\n      }\n    }\n\n    return null;\n  }\n\n  private _delayedAbort(type: PeerErrorType, message: string | Error): void {\n    setTimeout(() => {\n      this._abort(type, message);\n    }, 0);\n  }\n\n  /**\n   * Emits an error message and destroys the Peer.\n   * The Peer is not destroyed if it's in a disconnected state, in which case\n   * it retains its disconnected state and its existing connections.\n   */\n  private _abort(type: PeerErrorType, message: string | Error): void {\n    logger.error(\"Aborting!\");\n\n    this.emitError(type, message);\n\n    if (!this._lastServerId) {\n      this.destroy();\n    } else {\n      this.disconnect();\n    }\n  }\n\n  /** Emits a typed error message. */\n  emitError(type: PeerErrorType, err: string | Error): void {\n    logger.error(\"Error:\", err);\n\n    let error: Error & { type?: PeerErrorType };\n\n    if (typeof err === \"string\") {\n      error = new Error(err);\n    } else {\n      error = err as Error;\n    }\n\n    error.type = type;\n\n    this.emit(PeerEventType.Error, error);\n  }\n\n  /**\n   * Destroys the Peer: closes all active connections as well as the connection\n   *  to the server.\n   * Warning: The peer can no longer create or accept connections after being\n   *  destroyed.\n   */\n  destroy(): void {\n    if (this.destroyed) {\n      return;\n    }\n\n    logger.log(`Destroy peer with ID:${this.id}`);\n\n    this.disconnect();\n    this._cleanup();\n\n    this._destroyed = true;\n\n    this.emit(PeerEventType.Close);\n  }\n\n  /** Disconnects every connection on this peer. */\n  private _cleanup(): void {\n    for (let peerId of this._connections.keys()) {\n      this._cleanupPeer(peerId);\n      this._connections.delete(peerId);\n    }\n\n    this.socket.removeAllListeners();\n  }\n\n  /** Closes all connections to this peer. */\n  private _cleanupPeer(peerId: string): void {\n    const connections = this._connections.get(peerId);\n\n    if (!connections) return;\n\n    for (let connection of connections) {\n      connection.close();\n    }\n  }\n\n  /**\n   * Disconnects the Peer's connection to the PeerServer. Does not close any\n   *  active connections.\n   * Warning: The peer can no longer create or accept connections after being\n   *  disconnected. It also cannot reconnect to the server.\n   */\n  disconnect(): void {\n    if (this.disconnected) {\n      return;\n    }\n\n    const currentId = this.id;\n\n    logger.log(`Disconnect peer with ID:${currentId}`);\n\n    this._disconnected = true;\n    this._open = false;\n\n    this.socket.close();\n\n    this._lastServerId = currentId;\n    this._id = null;\n\n    this.emit(PeerEventType.Disconnected, currentId);\n  }\n\n  /** Attempts to reconnect with the same ID. */\n  reconnect(): void {\n    if (this.disconnected && !this.destroyed) {\n      logger.log(`Attempting reconnection to server with ID ${this._lastServerId}`);\n      this._disconnected = false;\n      this._initialize(this._lastServerId!);\n    } else if (this.destroyed) {\n      throw new Error(\"This peer cannot reconnect to the server. It has already been destroyed.\");\n    } else if (!this.disconnected && !this.open) {\n      // Do nothing. We're still connecting the first time.\n      logger.error(\"In a hurry? We're still trying to make the initial connection!\");\n    } else {\n      throw new Error(`Peer ${this.id} cannot reconnect because it is not disconnected from the server!`);\n    }\n  }\n\n  /**\n   * Get a list of available peer IDs. If you're running your own server, you'll\n   * want to set allow_discovery: true in the PeerServer options. If you're using\n   * the cloud server, email team@peerjs.com to get the functionality enabled for\n   * your key.\n   */\n  listAllPeers(cb = (_: any[]) => { }): void {\n    this._api.listAllPeers()\n      .then(peers => cb(peers))\n      .catch(error => this._abort(PeerErrorType.ServerError, error));\n  }\n}\n","import { util } from \"./util\";\nimport { Peer } from \"./peer\";\n\nexport const peerjs = {\n  Peer,\n  util,\n};\n\nexport default Peer;\n\n(<any>window).peerjs = peerjs;\n/** @deprecated Should use peerjs namespace */\n(<any>window).Peer = Peer;\n"],"names":["Supports","constructor","this","includes","navigator","platform","isWebRTCSupported","RTCPeerConnection","isBrowserSupported","browser","getBrowser","version","getVersion","supportedBrowsers","minChromeVersion","minFirefoxVersion","isIOS","minSafariVersion","webRTCAdapter","browserDetails","isUnifiedPlanSupported","window","RTCRtpTransceiver","prototype","tempPc","supported","addTransceiver","e","close","toString","DEFAULT_CONFIG","iceServers","urls","username","credential","sdpSemantics","util","Chrome","chrome","webRTC","audioVideo","data","binaryBlob","reliable","pc","dc","createDataChannel","ordered","binaryType","BinaryPack","noop","validateId","id","test","chunk","blob","chunks","size","total","Math","ceil","chunkedMTU","index","start","end","min","b","slice","push","__peerData","_dataCount","n","blobToArrayBuffer","cb","fr","FileReader","onload","evt","target","result","readAsArrayBuffer","binaryStringToArrayBuffer","binary","byteArray","Uint8Array","length","i","charCodeAt","buffer","randomToken","random","substr","isSecure","location","protocol","LogLevel","ConnectionEventType","ConnectionType","PeerEventType","PeerErrorType","SerializationType","SocketEventType","ServerMessageType","Disabled","logLevel","_logLevel","log","args","All","_print","warn","Warnings","error","Errors","setLogFunction","fn","rest","copy","Error","name","message","console","Socket","EventEmitter","secure","host","port","path","key","pingInterval","super","_baseUrl","token","_id","_socket","_disconnected","WebSocket","onmessage","event","JSON","parse","logger","emit","Message","onclose","_cleanup","Disconnected","onopen","_sendQueuedMessages","_scheduleHeartbeat","_wsPingTimer","setTimeout","_sendHeartbeat","_wsOpen","stringify","type","Heartbeat","send","readyState","copiedQueue","_messagesQueue","undefined","clearTimeout","Negotiator","connection","startConnection","options","peerConnection","_startPeerConnection","Media","_stream","_addTracksToConnection","originator","Data","dataConnection","dataChannel","label","initialize","_makeOffer","handleSDP","sdp","provider","config","_setupListeners","peerId","peer","connectionId","connectionType","onicecandidate","candidate","socket","Candidate","payload","dst","oniceconnectionstatechange","iceConnectionState","IceStateChanged","ondatachannel","channel","getConnection","ontrack","stream","streams","_addStreamToMediaConnection","cleanup","dataChannelNotClosed","signalingState","[object Object]","offer","createOffer","constraints","sdpTransform","setLocalDescription","metadata","serialization","Offer","err","emitError","WebRTC","err_1","answer","createAnswer","Answer","RTCSessionDescription","self","setRemoteDescription","_makeAnswer","ice","sdpMLineIndex","sdpMid","addIceCandidate","RTCIceCandidate","addTrack","getTracks","forEach","track","mediaConnection","addStream","BaseConnection","open","_open","MediaConnection","_localStream","ID_PREFIX","_negotiator","localStream","remoteStream","_remoteStream","Stream","handleMessage","handleCandidate","_payload","messages","_getMessages","_removeConnection","Close","EncodingQueue","fileReader","_processing","doNextTask","onerror","destroy","queue","_queue","processing","enque","abort","shift","DataConnection","Binary","_encodingQueue","on","ab","_bufferedSend","_dc","bufferSize","_bufferSize","_configureDataChannel","supports","Open","_handleDataMessage","datatype","deserializedData","BinaryUTF8","Blob","unpackedData","unpack","ArrayBuffer","String","_handleChunk","chunkInfo","_chunkedData","count","_buffer","removeAllListeners","chunked","pack","_sendChunks","msg","_buffering","_trySend","bufferedAmount","MAX_BUFFERED_AMOUNT","_tryBuffer","blobs","API","_options","_buildUrl","method","url","Date","getTime","response","fetch","status","text","pathError","CLOUD_HOST","helpfulError","json","Peer","userId","Map","Object","debug","CLOUD_PORT","DEFAULT_KEY","defaultConfig","hostname","logFunction","_api","_createServerConnection","_initialize","retrieveId","then","catch","_abort","ServerError","_delayedAbort","InvalidID","BrowserIncompatible","connections","plainConnections","create","k","v","_connections","destroyed","_destroyed","disconnected","_handleMessage","SocketError","Network","disconnect","SocketClosed","src","_lastServerId","IdTaken","UnavailableID","InvalidKey","Leave","_cleanupPeer","delete","Expire","PeerUnavailable","_addConnection","Call","Connection","_storeMessage","_lostMessages","has","set","get","connect","call","indexOf","splice","keys","currentId","reconnect","listAllPeers","_","peers","peerjs"],"mappings":"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"}