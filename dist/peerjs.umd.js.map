{"version":3,"file":"peerjs.umd.js","sources":["../lib/supports.ts","../lib/util.ts","../lib/logger.ts","../lib/enums.ts","../lib/socket.ts","../lib/negotiator.ts","../lib/baseconnection.ts","../lib/mediaconnection.ts","../lib/encodingQueue.ts","../lib/dataconnection.ts","../lib/api.ts","../lib/peer.ts","../lib/exports.ts"],"sourcesContent":["import { webRTCAdapter } from './adapter';\n\nexport const Supports = new class {\n  readonly isIOS = ['iPad', 'iPhone', 'iPod'].includes(navigator.platform);\n  readonly supportedBrowsers = ['firefox', 'chrome', 'safari'];\n\n  readonly minFirefoxVersion = 59;\n  readonly minChromeVersion = 72;\n  readonly minSafariVersion = 605;\n\n  isWebRTCSupported(): boolean {\n    return typeof RTCPeerConnection !== 'undefined';\n  };\n\n  isBrowserSupported(): boolean {\n    const browser = this.getBrowser();\n    const version = this.getVersion();\n\n    const validBrowser = this.supportedBrowsers.includes(browser);\n\n    if (!validBrowser) return false;\n\n    if (browser === 'chrome') return version >= this.minChromeVersion;\n    if (browser === 'firefox') return version >= this.minFirefoxVersion;\n    if (browser === 'safari') return !this.isIOS && version >= this.minSafariVersion;\n\n    return false;\n  }\n\n  getBrowser(): string {\n    return webRTCAdapter.browserDetails.browser;\n  }\n\n  getVersion(): number {\n    return webRTCAdapter.browserDetails.version || 0;\n  }\n\n  isUnifiedPlanSupported(): boolean {\n    const browser = this.getBrowser();\n    const version = webRTCAdapter.browserDetails.version || 0;\n\n    if (browser === 'chrome' && version < 72) return false;\n    if (browser === 'firefox' && version >= 59) return true;\n    if (!window.RTCRtpTransceiver || !('currentDirection' in RTCRtpTransceiver.prototype)) return false;\n\n    let tempPc: RTCPeerConnection;\n    let supported = false;\n\n    try {\n      tempPc = new RTCPeerConnection();\n      tempPc.addTransceiver('audio');\n      supported = true;\n    } catch (e) { }\n    finally {\n      if (tempPc) {\n        tempPc.close();\n      }\n    }\n\n    return supported;\n  }\n\n  toString(): string {\n    return `Supports: \n    browser:${this.getBrowser()} \n    version:${this.getVersion()} \n    isIOS:${this.isIOS} \n    isWebRTCSupported:${this.isWebRTCSupported()} \n    isBrowserSupported:${this.isBrowserSupported()} \n    isUnifiedPlanSupported:${this.isUnifiedPlanSupported()}`;\n  }\n}","import * as BinaryPack from \"peerjs-js-binarypack\";\nimport { Supports } from \"./supports\";\nimport { UtilSupportsObj } from \"..\";\n\nconst DEFAULT_CONFIG = {\n  iceServers: [\n    { urls: \"stun:stun.l.google.com:19302\" },\n    {\n      urls: \"turn:0.peerjs.com:3478\",\n      username: \"peerjs\",\n      credential: \"peerjsp\",\n    },\n  ],\n  sdpSemantics: \"unified-plan\",\n};\n\nexport const util = new (class {\n  noop(): void {}\n\n  readonly CLOUD_HOST = \"0.peerjs.com\";\n  readonly CLOUD_PORT = 443;\n\n  // Browsers that need chunking:\n  readonly chunkedBrowsers = { Chrome: 1, chrome: 1 };\n  readonly chunkedMTU = 16300; // The original 60000 bytes setting does not work when sending data from Firefox to Chrome, which is \"cut off\" after 16384 bytes and delivered individually.\n\n  // Returns browser-agnostic default config\n  readonly defaultConfig = DEFAULT_CONFIG;\n\n  readonly browser = Supports.getBrowser();\n  readonly browserVersion = Supports.getVersion();\n\n  // Lists which features are supported\n  readonly supports = (function () {\n    const supported: UtilSupportsObj = {\n      browser: Supports.isBrowserSupported(),\n      webRTC: Supports.isWebRTCSupported(),\n      audioVideo: false,\n      data: false,\n      binaryBlob: false,\n      reliable: false,\n    };\n\n    if (!supported.webRTC) return supported;\n\n    let pc: RTCPeerConnection;\n\n    try {\n      pc = new RTCPeerConnection(DEFAULT_CONFIG);\n\n      supported.audioVideo = true;\n\n      let dc: RTCDataChannel;\n\n      try {\n        dc = pc.createDataChannel(\"_PEERJSTEST\", { ordered: true });\n        supported.data = true;\n        supported.reliable = !!dc.ordered;\n\n        // Binary test\n        try {\n          dc.binaryType = \"blob\";\n          supported.binaryBlob = !Supports.isIOS;\n        } catch (e) {}\n      } catch (e) {\n      } finally {\n        if (dc) {\n          dc.close();\n        }\n      }\n    } catch (e) {\n    } finally {\n      if (pc) {\n        pc.close();\n      }\n    }\n\n    return supported;\n  })();\n\n  // Ensure alphanumeric ids\n  validateId(id: string): boolean {\n    // Allow empty ids\n    return !id || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.test(id);\n  }\n\n  pack = BinaryPack.pack;\n  unpack = BinaryPack.unpack;\n\n  // Binary stuff\n\n  _dataCount: number = 1;\n\n  chunk(\n    blob: Blob\n  ): { __peerData: number; n: number; total: number; data: Blob }[] {\n    const chunks = [];\n    const size = blob.size;\n    const total = Math.ceil(size / util.chunkedMTU);\n\n    let index = 0;\n    let start = 0;\n\n    while (start < size) {\n      const end = Math.min(size, start + util.chunkedMTU);\n      const b = blob.slice(start, end);\n\n      const chunk = {\n        __peerData: this._dataCount,\n        n: index,\n        data: b,\n        total,\n      };\n\n      chunks.push(chunk);\n\n      start = end;\n      index++;\n    }\n\n    this._dataCount++;\n\n    return chunks;\n  }\n\n  blobToArrayBuffer(\n    blob: Blob,\n    cb: (arg: ArrayBuffer | null) => void\n  ): FileReader {\n    const fr = new FileReader();\n\n    fr.onload = function (evt) {\n      if (evt.target) {\n        cb(evt.target.result as ArrayBuffer);\n      }\n    };\n\n    fr.readAsArrayBuffer(blob);\n\n    return fr;\n  }\n\n  binaryStringToArrayBuffer(binary: string): ArrayBuffer | SharedArrayBuffer {\n    const byteArray = new Uint8Array(binary.length);\n\n    for (let i = 0; i < binary.length; i++) {\n      byteArray[i] = binary.charCodeAt(i) & 0xff;\n    }\n\n    return byteArray.buffer;\n  }\n\n  randomToken(): string {\n    return Math.random().toString(36).substr(2);\n  }\n\n  isSecure(): boolean {\n    return location.protocol === \"https:\";\n  }\n})();\n","const LOG_PREFIX = 'PeerJS: ';\n\n/*\nPrints log messages depending on the debug level passed in. Defaults to 0.\n0  Prints no logs.\n1  Prints only errors.\n2  Prints errors and warnings.\n3  Prints all logs.\n*/\nexport enum LogLevel {\n    Disabled,\n    Errors,\n    Warnings,\n    All\n}\n\nclass Logger {\n    private _logLevel = LogLevel.Disabled;\n\n    get logLevel(): LogLevel { return this._logLevel; }\n\n    set logLevel(logLevel: LogLevel) { this._logLevel = logLevel; }\n\n    log(...args: any[]) {\n        if (this._logLevel >= LogLevel.All) {\n            this._print(LogLevel.All, ...args);\n        }\n    }\n\n    warn(...args: any[]) {\n        if (this._logLevel >= LogLevel.Warnings) {\n            this._print(LogLevel.Warnings, ...args);\n        }\n    }\n\n    error(...args: any[]) {\n        if (this._logLevel >= LogLevel.Errors) {\n            this._print(LogLevel.Errors, ...args);\n        }\n    }\n\n    setLogFunction(fn: (logLevel: LogLevel, ..._: any[]) => void): void {\n        this._print = fn;\n    }\n\n    private _print(logLevel: LogLevel, ...rest: any[]): void {\n        const copy = [LOG_PREFIX, ...rest];\n\n        for (let i in copy) {\n            if (copy[i] instanceof Error) {\n                copy[i] = \"(\" + copy[i].name + \") \" + copy[i].message;\n\n            }\n        }\n\n        if (logLevel >= LogLevel.All) {\n            console.log(...copy);\n        } else if (logLevel >= LogLevel.Warnings) {\n            console.warn(\"WARNING\", ...copy);\n        } else if (logLevel >= LogLevel.Errors) {\n            console.error(\"ERROR\", ...copy);\n        }\n    }\n}\n\nexport default new Logger();","export enum ConnectionEventType {\n  Open = \"open\",\n  Stream = \"stream\",\n  Data = \"data\",\n  Close = \"close\",\n  Error = \"error\",\n  IceStateChanged = \"iceStateChanged\"\n}\n\nexport enum ConnectionType {\n  Data = \"data\",\n  Media = \"media\"\n}\n\nexport enum PeerEventType {\n  Open = \"open\",\n  Close = \"close\",\n  Connection = \"connection\",\n  Call = \"call\",\n  Disconnected = \"disconnected\",\n  Error = \"error\"\n}\n\nexport enum PeerErrorType {\n  BrowserIncompatible = \"browser-incompatible\",\n  Disconnected = \"disconnected\",\n  InvalidID = \"invalid-id\",\n  InvalidKey = \"invalid-key\",\n  Network = \"network\",\n  PeerUnavailable = \"peer-unavailable\",\n  SslUnavailable = \"ssl-unavailable\",\n  ServerError = \"server-error\",\n  SocketError = \"socket-error\",\n  SocketClosed = \"socket-closed\",\n  UnavailableID = \"unavailable-id\",\n  WebRTC = \"webrtc\"\n}\n\nexport enum SerializationType {\n  Binary = \"binary\",\n  BinaryUTF8 = \"binary-utf8\",\n  JSON = \"json\"\n}\n\nexport enum SocketEventType {\n  Message = \"message\",\n  Disconnected = \"disconnected\",\n  Error = \"error\",\n  Close = \"close\"\n}\n\nexport enum ServerMessageType {\n  Heartbeat = \"HEARTBEAT\",\n  Candidate = \"CANDIDATE\",\n  Offer = \"OFFER\",\n  Answer = \"ANSWER\",\n  Open = \"OPEN\", // The connection to the server is open.\n  Error = \"ERROR\", // Server error.\n  IdTaken = \"ID-TAKEN\", // The selected ID is taken.\n  InvalidKey = \"INVALID-KEY\", // The given API key cannot be found.\n  Leave = \"LEAVE\", // Another peer has closed its connection to this peer.\n  Expire = \"EXPIRE\" // The offer sent to a peer has expired without response.\n\n}","import { EventEmitter } from \"eventemitter3\";\nimport logger from \"./logger\";\nimport { SocketEventType, ServerMessageType } from \"./enums\";\n\n/**\n * An abstraction on top of WebSockets to provide fastest\n * possible connection for peers.\n */\nexport class Socket extends EventEmitter {\n  private _disconnected: boolean = true;\n  private _id?: string;\n  private _messagesQueue: Array<object> = [];\n  private _socket?: WebSocket;\n  private _wsPingTimer?: any;\n  private readonly _baseUrl: string;\n\n  constructor(\n    secure: any,\n    host: string,\n    port: number,\n    path: string,\n    key: string,\n    private readonly pingInterval: number = 5000,\n  ) {\n    super();\n\n    const wsProtocol = secure ? \"wss://\" : \"ws://\";\n\n    this._baseUrl = wsProtocol + host + \":\" + port + path + \"peerjs?key=\" + key;\n  }\n\n  start(id: string, token: string): void {\n    this._id = id;\n\n    const wsUrl = `${this._baseUrl}&id=${id}&token=${token}`;\n\n    if (!!this._socket || !this._disconnected) {\n      return;\n    }\n\n    this._socket = new WebSocket(wsUrl);\n    this._disconnected = false;\n\n    this._socket.onmessage = (event) => {\n      let data;\n\n      try {\n        data = JSON.parse(event.data);\n        logger.log(\"Server message received:\", data);\n      } catch (e) {\n        logger.log(\"Invalid server message\", event.data);\n        return;\n      }\n\n      this.emit(SocketEventType.Message, data);\n    };\n\n    this._socket.onclose = (event) => {\n      if (this._disconnected) {\n        return;\n      }\n\n      logger.log(\"Socket closed.\", event);\n\n      this._cleanup();\n      this._disconnected = true;\n\n      this.emit(SocketEventType.Disconnected);\n    };\n\n    // Take care of the queue of connections if necessary and make sure Peer knows\n    // socket is open.\n    this._socket.onopen = () => {\n      if (this._disconnected) {\n        return;\n      }\n\n      this._sendQueuedMessages();\n\n      logger.log(\"Socket open\");\n\n      this._scheduleHeartbeat();\n    };\n  }\n\n  private _scheduleHeartbeat(): void {\n    this._wsPingTimer = setTimeout(() => {\n      this._sendHeartbeat();\n    }, this.pingInterval);\n  }\n\n  private _sendHeartbeat(): void {\n    if (!this._wsOpen()) {\n      logger.log(`Cannot send heartbeat, because socket closed`);\n      return;\n    }\n\n    const message = JSON.stringify({ type: ServerMessageType.Heartbeat });\n\n    this._socket!.send(message);\n\n    this._scheduleHeartbeat();\n  }\n\n  /** Is the websocket currently open? */\n  private _wsOpen(): boolean {\n    return !!this._socket && this._socket.readyState === 1;\n  }\n\n  /** Send queued messages. */\n  private _sendQueuedMessages(): void {\n    //Create copy of queue and clear it,\n    //because send method push the message back to queue if smth will go wrong\n    const copiedQueue = [...this._messagesQueue];\n    this._messagesQueue = [];\n\n    for (const message of copiedQueue) {\n      this.send(message);\n    }\n  }\n\n  /** Exposed send for DC & Peer. */\n  send(data: any): void {\n    if (this._disconnected) {\n      return;\n    }\n\n    // If we didn't get an ID yet, we can't yet send anything so we should queue\n    // up these messages.\n    if (!this._id) {\n      this._messagesQueue.push(data);\n      return;\n    }\n\n    if (!data.type) {\n      this.emit(SocketEventType.Error, \"Invalid message\");\n      return;\n    }\n\n    if (!this._wsOpen()) {\n      return;\n    }\n\n    const message = JSON.stringify(data);\n\n    this._socket!.send(message);\n  }\n\n  close(): void {\n    if (this._disconnected) {\n      return;\n    }\n\n    this._cleanup();\n\n    this._disconnected = true;\n  }\n\n  private _cleanup(): void {\n    if (!!this._socket) {\n      this._socket.onopen = this._socket.onmessage = this._socket.onclose = null;\n      this._socket.close();\n      this._socket = undefined;\n    }\n\n    clearTimeout(this._wsPingTimer!);\n  }\n}\n","import { util } from \"./util\";\nimport logger from \"./logger\";\nimport { MediaConnection } from \"./mediaconnection\";\nimport { DataConnection } from \"./dataconnection\";\nimport { ConnectionType, PeerErrorType, ConnectionEventType, ServerMessageType } from \"./enums\";\nimport { BaseConnection } from \"./baseconnection\";\n\n/**\n * Manages all negotiations between Peers.\n */\nexport class Negotiator {\n  constructor(readonly connection: BaseConnection) { }\n\n  /** Returns a PeerConnection object set up correctly (for data, media). */\n  startConnection(options: any) {\n    const peerConnection = this._startPeerConnection();\n\n    // Set the connection's PC.\n    this.connection.peerConnection = peerConnection;\n\n    if (this.connection.type === ConnectionType.Media && options._stream) {\n      this._addTracksToConnection(options._stream, peerConnection);\n    }\n\n    // What do we need to do now?\n    if (options.originator) {\n      if (this.connection.type === ConnectionType.Data) {\n        const dataConnection = <DataConnection>this.connection;\n\n        const config: RTCDataChannelInit = { ordered: !!options.reliable };\n\n        const dataChannel = peerConnection.createDataChannel(\n          dataConnection.label,\n          config\n        );\n        dataConnection.initialize(dataChannel);\n      }\n\n      this._makeOffer();\n    } else {\n      this.handleSDP(\"OFFER\", options.sdp);\n    }\n  }\n\n  /** Start a PC. */\n  private _startPeerConnection(): RTCPeerConnection {\n    logger.log(\"Creating RTCPeerConnection.\");\n\n    const peerConnection = new RTCPeerConnection(this.connection.provider.options.config);\n\n    this._setupListeners(peerConnection);\n\n    return peerConnection;\n  }\n\n  /** Set up various WebRTC listeners. */\n  private _setupListeners(\n    peerConnection: RTCPeerConnection\n  ) {\n    const peerId = this.connection.peer;\n    const connectionId = this.connection.connectionId;\n    const connectionType = this.connection.type;\n    const provider = this.connection.provider;\n\n    // ICE CANDIDATES.\n    logger.log(\"Listening for ICE candidates.\");\n\n    peerConnection.onicecandidate = (evt) => {\n      if (!evt.candidate || !evt.candidate.candidate) return;\n\n      logger.log(`Received ICE candidates for ${peerId}:`, evt.candidate);\n\n      provider.socket.send({\n        type: ServerMessageType.Candidate,\n        payload: {\n          candidate: evt.candidate,\n          type: connectionType,\n          connectionId: connectionId\n        },\n        dst: peerId\n      });\n    };\n\n    peerConnection.oniceconnectionstatechange = () => {\n      switch (peerConnection.iceConnectionState) {\n        case \"failed\":\n          logger.log(\n            \"iceConnectionState is failed, closing connections to \" +\n            peerId\n          );\n          this.connection.emit(\n            ConnectionEventType.Error,\n            new Error(\"Negotiation of connection to \" + peerId + \" failed.\")\n          );\n          this.connection.close();\n          break;\n        case \"closed\":\n          logger.log(\n            \"iceConnectionState is closed, closing connections to \" +\n            peerId\n          );\n          this.connection.emit(\n            ConnectionEventType.Error,\n            new Error(\"Connection to \" + peerId + \" closed.\")\n          );\n          this.connection.close();\n          break;\n        case \"disconnected\":\n          logger.log(\n            \"iceConnectionState changed to disconnected on the connection with \" +\n            peerId\n          );\n          break;\n        case \"completed\":\n          peerConnection.onicecandidate = util.noop;\n          break;\n      }\n\n      this.connection.emit(ConnectionEventType.IceStateChanged, peerConnection.iceConnectionState);\n    };\n\n    // DATACONNECTION.\n    logger.log(\"Listening for data channel\");\n    // Fired between offer and answer, so options should already be saved\n    // in the options hash.\n    peerConnection.ondatachannel = (evt) => {\n      logger.log(\"Received data channel\");\n\n      const dataChannel = evt.channel;\n      const connection = <DataConnection>(\n        provider.getConnection(peerId, connectionId)\n      );\n\n      connection.initialize(dataChannel);\n    };\n\n    // MEDIACONNECTION.\n    logger.log(\"Listening for remote stream\");\n\n    peerConnection.ontrack = (evt) => {\n      logger.log(\"Received remote stream\");\n\n      const stream = evt.streams[0];\n      const connection = provider.getConnection(peerId, connectionId);\n\n      if (connection.type === ConnectionType.Media) {\n        const mediaConnection = <MediaConnection>connection;\n\n        this._addStreamToMediaConnection(stream, mediaConnection);\n      }\n    };\n  }\n\n  cleanup(): void {\n    logger.log(\"Cleaning up PeerConnection to \" + this.connection.peer);\n\n    const peerConnection = this.connection.peerConnection;\n\n    if (!peerConnection) {\n      return;\n    }\n\n    this.connection.peerConnection = null;\n\n    //unsubscribe from all PeerConnection's events\n    peerConnection.onicecandidate = peerConnection.oniceconnectionstatechange = peerConnection.ondatachannel = peerConnection.ontrack = () => { };\n\n    const peerConnectionNotClosed = peerConnection.signalingState !== \"closed\";\n    let dataChannelNotClosed = false;\n\n    if (this.connection.type === ConnectionType.Data) {\n      const dataConnection = <DataConnection>this.connection;\n      const dataChannel = dataConnection.dataChannel;\n\n      if (dataChannel) {\n        dataChannelNotClosed = !!dataChannel.readyState && dataChannel.readyState !== \"closed\";\n      }\n    }\n\n    if (peerConnectionNotClosed || dataChannelNotClosed) {\n      peerConnection.close();\n    }\n  }\n\n  private async _makeOffer(): Promise<void> {\n    const peerConnection = this.connection.peerConnection;\n    const provider = this.connection.provider;\n\n    try {\n      const offer = await peerConnection.createOffer(\n        this.connection.options.constraints\n      );\n\n      logger.log(\"Created offer.\");\n\n      if (this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform === 'function') {\n        offer.sdp = this.connection.options.sdpTransform(offer.sdp) || offer.sdp;\n      }\n\n      try {\n        await peerConnection.setLocalDescription(offer);\n\n        logger.log(\"Set localDescription:\", offer, `for:${this.connection.peer}`);\n\n        let payload: any = {\n          sdp: offer,\n          type: this.connection.type,\n          connectionId: this.connection.connectionId,\n          metadata: this.connection.metadata,\n          browser: util.browser\n        };\n\n        if (this.connection.type === ConnectionType.Data) {\n          const dataConnection = <DataConnection>this.connection;\n\n          payload = {\n            ...payload,\n            label: dataConnection.label,\n            reliable: dataConnection.reliable,\n            serialization: dataConnection.serialization\n          };\n        }\n\n        provider.socket.send({\n          type: ServerMessageType.Offer,\n          payload,\n          dst: this.connection.peer\n        });\n      } catch (err) {\n        // TODO: investigate why _makeOffer is being called from the answer\n        if (\n          err !=\n          \"OperationError: Failed to set local offer sdp: Called in wrong state: kHaveRemoteOffer\"\n        ) {\n          provider.emitError(PeerErrorType.WebRTC, err);\n          logger.log(\"Failed to setLocalDescription, \", err);\n        }\n      }\n    } catch (err_1) {\n      provider.emitError(PeerErrorType.WebRTC, err_1);\n      logger.log(\"Failed to createOffer, \", err_1);\n    }\n  }\n\n  private async _makeAnswer(): Promise<void> {\n    const peerConnection = this.connection.peerConnection;\n    const provider = this.connection.provider;\n\n    try {\n      const answer = await peerConnection.createAnswer();\n      logger.log(\"Created answer.\");\n\n      if (this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform === 'function') {\n        answer.sdp = this.connection.options.sdpTransform(answer.sdp) || answer.sdp;\n      }\n\n      try {\n        await peerConnection.setLocalDescription(answer);\n\n        logger.log(`Set localDescription:`, answer, `for:${this.connection.peer}`);\n\n        provider.socket.send({\n          type: ServerMessageType.Answer,\n          payload: {\n            sdp: answer,\n            type: this.connection.type,\n            connectionId: this.connection.connectionId,\n            browser: util.browser\n          },\n          dst: this.connection.peer\n        });\n      } catch (err) {\n        provider.emitError(PeerErrorType.WebRTC, err);\n        logger.log(\"Failed to setLocalDescription, \", err);\n      }\n    } catch (err_1) {\n      provider.emitError(PeerErrorType.WebRTC, err_1);\n      logger.log(\"Failed to create answer, \", err_1);\n    }\n  }\n\n  /** Handle an SDP. */\n  async handleSDP(\n    type: string,\n    sdp: any\n  ): Promise<void> {\n    sdp = new RTCSessionDescription(sdp);\n    const peerConnection = this.connection.peerConnection;\n    const provider = this.connection.provider;\n\n    logger.log(\"Setting remote description\", sdp);\n\n    const self = this;\n\n    try {\n      await peerConnection.setRemoteDescription(sdp);\n      logger.log(`Set remoteDescription:${type} for:${this.connection.peer}`);\n      if (type === \"OFFER\") {\n        await self._makeAnswer();\n      }\n    } catch (err) {\n      provider.emitError(PeerErrorType.WebRTC, err);\n      logger.log(\"Failed to setRemoteDescription, \", err);\n    }\n  }\n\n  /** Handle a candidate. */\n  async handleCandidate(ice: any): Promise<void> {\n    logger.log(`handleCandidate:`, ice);\n\n    const candidate = ice.candidate;\n    const sdpMLineIndex = ice.sdpMLineIndex;\n    const sdpMid = ice.sdpMid;\n    const peerConnection = this.connection.peerConnection;\n    const provider = this.connection.provider;\n\n    try {\n      await peerConnection.addIceCandidate(\n        new RTCIceCandidate({\n          sdpMid: sdpMid,\n          sdpMLineIndex: sdpMLineIndex,\n          candidate: candidate\n        })\n      );\n      logger.log(`Added ICE candidate for:${this.connection.peer}`);\n    } catch (err) {\n      provider.emitError(PeerErrorType.WebRTC, err);\n      logger.log(\"Failed to handleCandidate, \", err);\n    }\n  }\n\n  private _addTracksToConnection(\n    stream: MediaStream,\n    peerConnection: RTCPeerConnection\n  ): void {\n    logger.log(`add tracks from stream ${stream.id} to peer connection`);\n\n    if (!peerConnection.addTrack) {\n      return logger.error(\n        `Your browser does't support RTCPeerConnection#addTrack. Ignored.`\n      );\n    }\n\n    stream.getTracks().forEach(track => {\n      peerConnection.addTrack(track, stream);\n    });\n  }\n\n  private _addStreamToMediaConnection(\n    stream: MediaStream,\n    mediaConnection: MediaConnection\n  ): void {\n    logger.log(\n      `add stream ${stream.id} to media connection ${\n      mediaConnection.connectionId\n      }`\n    );\n\n    mediaConnection.addStream(stream);\n  }\n}\n","import { EventEmitter } from \"eventemitter3\";\nimport { Peer } from \"./peer\";\nimport { ServerMessage } from \"./servermessage\";\nimport { ConnectionType } from \"./enums\";\n\nexport abstract class BaseConnection extends EventEmitter {\n  protected _open = false;\n\n  readonly metadata: any;\n  connectionId: string;\n\n  peerConnection: RTCPeerConnection;\n\n  abstract get type(): ConnectionType;\n\n  get open() {\n    return this._open;\n  }\n\n  constructor(\n    readonly peer: string,\n    public provider: Peer,\n    readonly options: any\n  ) {\n    super();\n\n    this.metadata = options.metadata;\n  }\n\n  abstract close(): void;\n\n  abstract handleMessage(message: ServerMessage): void;\n}\n","import { util } from \"./util\";\nimport logger from \"./logger\";\nimport { Negotiator } from \"./negotiator\";\nimport { ConnectionType, ConnectionEventType, ServerMessageType } from \"./enums\";\nimport { Peer } from \"./peer\";\nimport { BaseConnection } from \"./baseconnection\";\nimport { ServerMessage } from \"./servermessage\";\nimport { AnswerOption } from \"..\";\n\n/**\n * Wraps the streaming interface between two Peers.\n */\nexport class MediaConnection extends BaseConnection {\n  private static readonly ID_PREFIX = \"mc_\";\n\n  private _negotiator: Negotiator;\n  private _localStream: MediaStream;\n  private _remoteStream: MediaStream;\n\n  get type() {\n    return ConnectionType.Media;\n  }\n\n  get localStream(): MediaStream { return this._localStream; }\n  get remoteStream(): MediaStream { return this._remoteStream; }\n\n  constructor(peerId: string, provider: Peer, options: any) {\n    super(peerId, provider, options);\n\n    this._localStream = this.options._stream;\n    this.connectionId =\n      this.options.connectionId ||\n      MediaConnection.ID_PREFIX + util.randomToken();\n\n    this._negotiator = new Negotiator(this);\n\n    if (this._localStream) {\n      this._negotiator.startConnection({\n        _stream: this._localStream,\n        originator: true\n      });\n    }\n  }\n\n  addStream(remoteStream) {\n    logger.log(\"Receiving stream\", remoteStream);\n\n    this._remoteStream = remoteStream;\n    super.emit(ConnectionEventType.Stream, remoteStream); // Should we call this `open`?\n  }\n\n  handleMessage(message: ServerMessage): void {\n    const type = message.type;\n    const payload = message.payload;\n\n    switch (message.type) {\n      case ServerMessageType.Answer:\n        // Forward to negotiator\n        this._negotiator.handleSDP(type, payload.sdp);\n        this._open = true;\n        break;\n      case ServerMessageType.Candidate:\n        this._negotiator.handleCandidate(payload.candidate);\n        break;\n      default:\n        logger.warn(`Unrecognized message type:${type} from peer:${this.peer}`);\n        break;\n    }\n  }\n\n  answer(stream: MediaStream, options: AnswerOption = {}): void {\n    if (this._localStream) {\n      logger.warn(\n        \"Local stream already exists on this MediaConnection. Are you answering a call twice?\"\n      );\n      return;\n    }\n\n    this._localStream = stream;\n\n    if (options && options.sdpTransform) {\n      this.options.sdpTransform = options.sdpTransform;\n    }\n\n    this._negotiator.startConnection({ ...this.options._payload, _stream: stream });\n    // Retrieve lost messages stored because PeerConnection not set up.\n    const messages = this.provider._getMessages(this.connectionId);\n\n    for (let message of messages) {\n      this.handleMessage(message);\n    }\n\n    this._open = true;\n  }\n\n  /**\n   * Exposed functionality for users.\n   */\n\n  /** Allows user to close connection. */\n  close(): void {\n    if (this._negotiator) {\n      this._negotiator.cleanup();\n      this._negotiator = null;\n    }\n\n    this._localStream = null;\n    this._remoteStream = null;\n\n    if (this.provider) {\n      this.provider._removeConnection(this);\n\n      this.provider = null;\n    }\n\n    if (this.options && this.options._stream) {\n      this.options._stream = null;\n    }\n\n    if (!this.open) {\n      return;\n    }\n\n    this._open = false;\n\n    super.emit(ConnectionEventType.Close);\n  }\n}\n","import { EventEmitter } from \"eventemitter3\";\nimport logger from \"./logger\";\n\nexport class EncodingQueue extends EventEmitter {\n  readonly fileReader: FileReader = new FileReader();\n\n  private _queue: Blob[] = [];\n  private _processing: boolean = false;\n\n  constructor() {\n    super();\n\n    this.fileReader.onload = (evt) => {\n      this._processing = false;\n\n      if (evt.target) {\n        this.emit('done', evt.target.result as ArrayBuffer);\n      }\n\n      this.doNextTask();\n    };\n\n    this.fileReader.onerror = (evt) => {\n      logger.error(`EncodingQueue error:`, evt);\n      this._processing = false;\n      this.destroy();\n      this.emit('error', evt);\n    }\n  }\n\n  get queue(): Blob[] {\n    return this._queue;\n  }\n\n  get size(): number {\n    return this.queue.length;\n  }\n\n  get processing(): boolean {\n    return this._processing;\n  }\n\n  enque(blob: Blob): void {\n    this.queue.push(blob);\n\n    if (this.processing) return;\n\n    this.doNextTask();\n  }\n\n  destroy(): void {\n    this.fileReader.abort();\n    this._queue = [];\n  }\n\n  private doNextTask(): void {\n    if (this.size === 0) return;\n    if (this.processing) return;\n\n    this._processing = true;\n\n    this.fileReader.readAsArrayBuffer(this.queue.shift());\n  }\n}","import { util } from \"./util\";\nimport logger from \"./logger\";\nimport { Negotiator } from \"./negotiator\";\nimport {\n  ConnectionType,\n  ConnectionEventType,\n  SerializationType,\n  ServerMessageType\n} from \"./enums\";\nimport { Peer } from \"./peer\";\nimport { BaseConnection } from \"./baseconnection\";\nimport { ServerMessage } from \"./servermessage\";\nimport { EncodingQueue } from './encodingQueue';\nimport { DataConnection as IDataConnection } from '../index';\n\n/**\n * Wraps a DataChannel between two Peers.\n */\nexport class DataConnection extends BaseConnection implements IDataConnection {\n  private static readonly ID_PREFIX = \"dc_\";\n  private static readonly MAX_BUFFERED_AMOUNT = 8 * 1024 * 1024;\n\n  private _negotiator: Negotiator;\n  readonly label: string;\n  readonly serialization: SerializationType;\n  readonly reliable: boolean;\n  stringify: (data: any) => string = JSON.stringify;\n  parse: (data: string) => any = JSON.parse;\n\n  get type() {\n    return ConnectionType.Data;\n  }\n\n  private _buffer: any[] = [];\n  private _bufferSize = 0;\n  private _buffering = false;\n  private _chunkedData: {\n    [id: number]: {\n      data: Blob[],\n      count: number,\n      total: number\n    }\n  } = {};\n\n  private _dc: RTCDataChannel;\n  private _encodingQueue = new EncodingQueue();\n\n  get dataChannel(): RTCDataChannel {\n    return this._dc;\n  }\n\n  get bufferSize(): number { return this._bufferSize; }\n\n  constructor(peerId: string, provider: Peer, options: any) {\n    super(peerId, provider, options);\n\n    this.connectionId =\n      this.options.connectionId || DataConnection.ID_PREFIX + util.randomToken();\n\n    this.label = this.options.label || this.connectionId;\n    this.serialization = this.options.serialization || SerializationType.Binary;\n    this.reliable = !!this.options.reliable;\n\n    this._encodingQueue.on('done', (ab: ArrayBuffer) => {\n      this._bufferedSend(ab);\n    });\n\n    this._encodingQueue.on('error', () => {\n      logger.error(`DC#${this.connectionId}: Error occured in encoding from blob to arraybuffer, close DC`);\n      this.close();\n    });\n\n    this._negotiator = new Negotiator(this);\n\n    this._negotiator.startConnection(\n      this.options._payload || {\n        originator: true\n      }\n    );\n  }\n\n  /** Called by the Negotiator when the DataChannel is ready. */\n  initialize(dc: RTCDataChannel): void {\n    this._dc = dc;\n    this._configureDataChannel();\n  }\n\n  private _configureDataChannel(): void {\n    if (!util.supports.binaryBlob || util.supports.reliable) {\n      this.dataChannel.binaryType = \"arraybuffer\";\n    }\n\n    this.dataChannel.onopen = () => {\n      logger.log(`DC#${this.connectionId} dc connection success`);\n      this._open = true;\n      this.emit(ConnectionEventType.Open);\n    };\n\n    this.dataChannel.onmessage = (e) => {\n      logger.log(`DC#${this.connectionId} dc onmessage:`, e.data);\n      this._handleDataMessage(e);\n    };\n\n    this.dataChannel.onclose = () => {\n      logger.log(`DC#${this.connectionId} dc closed for:`, this.peer);\n      this.close();\n    };\n  }\n\n  // Handles a DataChannel message.\n  private _handleDataMessage({ data }: { data: Blob | ArrayBuffer | string }): void {\n    const datatype = data.constructor;\n\n    const isBinarySerialization = this.serialization === SerializationType.Binary ||\n      this.serialization === SerializationType.BinaryUTF8;\n\n    let deserializedData: any = data;\n\n    if (isBinarySerialization) {\n      if (datatype === Blob) {\n        // Datatype should never be blob\n        util.blobToArrayBuffer(data as Blob, (ab) => {\n          const unpackedData = util.unpack(ab);\n          this.emit(ConnectionEventType.Data, unpackedData);\n        });\n        return;\n      } else if (datatype === ArrayBuffer) {\n        deserializedData = util.unpack(data as ArrayBuffer);\n      } else if (datatype === String) {\n        // String fallback for binary data for browsers that don't support binary yet\n        const ab = util.binaryStringToArrayBuffer(data as string);\n        deserializedData = util.unpack(ab);\n      }\n    } else if (this.serialization === SerializationType.JSON) {\n      deserializedData = this.parse(data as string);\n    }\n\n    // Check if we've chunked--if so, piece things back together.\n    // We're guaranteed that this isn't 0.\n    if (deserializedData.__peerData) {\n      this._handleChunk(deserializedData);\n      return;\n    }\n\n    super.emit(ConnectionEventType.Data, deserializedData);\n  }\n\n  private _handleChunk(data: { __peerData: number, n: number, total: number, data: Blob }): void {\n    const id = data.__peerData;\n    const chunkInfo = this._chunkedData[id] || {\n      data: [],\n      count: 0,\n      total: data.total\n    };\n\n    chunkInfo.data[data.n] = data.data;\n    chunkInfo.count++;\n    this._chunkedData[id] = chunkInfo;\n\n    if (chunkInfo.total === chunkInfo.count) {\n      // Clean up before making the recursive call to `_handleDataMessage`.\n      delete this._chunkedData[id];\n\n      // We've received all the chunks--time to construct the complete data.\n      const data = new Blob(chunkInfo.data);\n      this._handleDataMessage({ data });\n    }\n  }\n\n  /**\n   * Exposed functionality for users.\n   */\n\n  /** Allows user to close connection. */\n  close(): void {\n    this._buffer = [];\n    this._bufferSize = 0;\n    this._chunkedData = {};\n\n    if (this._negotiator) {\n      this._negotiator.cleanup();\n      this._negotiator = null;\n    }\n\n    if (this.provider) {\n      this.provider._removeConnection(this);\n\n      this.provider = null;\n    }\n\n    if (this.dataChannel) {\n      this.dataChannel.onopen = null;\n      this.dataChannel.onmessage = null;\n      this.dataChannel.onclose = null;\n      this._dc = null;\n    }\n\n    if (this._encodingQueue) {\n      this._encodingQueue.destroy();\n      this._encodingQueue.removeAllListeners();\n      this._encodingQueue = null;\n    }\n\n    if (!this.open) {\n      return;\n    }\n\n    this._open = false;\n\n    super.emit(ConnectionEventType.Close);\n  }\n\n  /** Allows user to send data. */\n  send(data: any, chunked?: boolean): void {\n    if (!this.open) {\n      super.emit(\n        ConnectionEventType.Error,\n        new Error(\n          \"Connection is not open. You should listen for the `open` event before sending messages.\"\n        )\n      );\n      return;\n    }\n\n    if (this.serialization === SerializationType.JSON) {\n      this._bufferedSend(this.stringify(data));\n    } else if (\n      this.serialization === SerializationType.Binary ||\n      this.serialization === SerializationType.BinaryUTF8\n    ) {\n      const blob = util.pack(data);\n\n      if (!chunked && blob.size > util.chunkedMTU) {\n        this._sendChunks(blob);\n        return;\n      }\n\n      if (!util.supports.binaryBlob) {\n        // We only do this if we really need to (e.g. blobs are not supported),\n        // because this conversion is costly.\n        this._encodingQueue.enque(blob);\n      } else {\n        this._bufferedSend(blob);\n      }\n    } else {\n      this._bufferedSend(data);\n    }\n  }\n\n  private _bufferedSend(msg: any): void {\n    if (this._buffering || !this._trySend(msg)) {\n      this._buffer.push(msg);\n      this._bufferSize = this._buffer.length;\n    }\n  }\n\n  // Returns true if the send succeeds.\n  private _trySend(msg: any): boolean {\n    if (!this.open) {\n      return false;\n    }\n\n    if (this.dataChannel.bufferedAmount > DataConnection.MAX_BUFFERED_AMOUNT) {\n      this._buffering = true;\n      setTimeout(() => {\n        this._buffering = false;\n        this._tryBuffer();\n      }, 50);\n\n      return false;\n    }\n\n    try {\n      this.dataChannel.send(msg);\n    } catch (e) {\n      logger.error(`DC#:${this.connectionId} Error when sending:`, e);\n      this._buffering = true;\n\n      this.close();\n\n      return false;\n    }\n\n    return true;\n  }\n\n  // Try to send the first message in the buffer.\n  private _tryBuffer(): void {\n    if (!this.open) {\n      return;\n    }\n\n    if (this._buffer.length === 0) {\n      return;\n    }\n\n    const msg = this._buffer[0];\n\n    if (this._trySend(msg)) {\n      this._buffer.shift();\n      this._bufferSize = this._buffer.length;\n      this._tryBuffer();\n    }\n  }\n\n  private _sendChunks(blob: Blob): void {\n    const blobs = util.chunk(blob);\n    logger.log(`DC#${this.connectionId} Try to send ${blobs.length} chunks...`);\n\n    for (let blob of blobs) {\n      this.send(blob, true);\n    }\n  }\n\n  handleMessage(message: ServerMessage): void {\n    const payload = message.payload;\n\n    switch (message.type) {\n      case ServerMessageType.Answer:\n        this._negotiator.handleSDP(message.type, payload.sdp);\n        break;\n      case ServerMessageType.Candidate:\n        this._negotiator.handleCandidate(payload.candidate);\n        break;\n      default:\n        logger.warn(\n          \"Unrecognized message type:\",\n          message.type,\n          \"from peer:\",\n          this.peer\n        );\n        break;\n    }\n  }\n}\n","import { util } from \"./util\";\nimport logger from \"./logger\";\n\nexport class API {\n  constructor(private readonly _options: any) { }\n\n  private _buildUrl(method: string): string {\n    const protocol = this._options.secure ? \"https://\" : \"http://\";\n    let url =\n      protocol +\n      this._options.host +\n      \":\" +\n      this._options.port +\n      this._options.path +\n      this._options.key +\n      \"/\" +\n      method;\n    const queryString = \"?ts=\" + new Date().getTime() + \"\" + Math.random();\n    url += queryString;\n\n    return url;\n  }\n\n  /** Get a unique ID from the server via XHR and initialize with it. */\n  async retrieveId(): Promise<string> {\n    const url = this._buildUrl(\"id\");\n\n    try {\n      const response = await fetch(url);\n\n      if (response.status !== 200) {\n        throw new Error(`Error. Status:${response.status}`);\n      }\n\n      return response.text();\n    } catch (error) {\n      logger.error(\"Error retrieving ID\", error);\n\n      let pathError = \"\";\n\n      if (\n        this._options.path === \"/\" &&\n        this._options.host !== util.CLOUD_HOST\n      ) {\n        pathError =\n          \" If you passed in a `path` to your self-hosted PeerServer, \" +\n          \"you'll also need to pass in that same path when creating a new \" +\n          \"Peer.\";\n      }\n\n      throw new Error(\"Could not get an ID from the server.\" + pathError);\n    }\n  }\n\n  /** @deprecated */\n  async listAllPeers(): Promise<any[]> {\n    const url = this._buildUrl(\"peers\");\n\n    try {\n      const response = await fetch(url);\n\n      if (response.status !== 200) {\n        if (response.status === 401) {\n          let helpfulError = \"\";\n\n          if (this._options.host === util.CLOUD_HOST) {\n            helpfulError =\n              \"It looks like you're using the cloud server. You can email \" +\n              \"team@peerjs.com to enable peer listing for your API key.\";\n          } else {\n            helpfulError =\n              \"You need to enable `allow_discovery` on your self-hosted \" +\n              \"PeerServer to use this feature.\";\n          }\n\n          throw new Error(\"It doesn't look like you have permission to list peers IDs. \" +\n            helpfulError);\n        }\n\n        throw new Error(`Error. Status:${response.status}`);\n      }\n\n      return response.json();\n    } catch (error) {\n      logger.error(\"Error retrieving list peers\", error);\n\n      throw new Error(\"Could not get list peers from the server.\" + error);\n    }\n  }\n}\n","import { EventEmitter } from \"eventemitter3\";\nimport { util } from \"./util\";\nimport logger, { LogLevel } from \"./logger\";\nimport { Socket } from \"./socket\";\nimport { MediaConnection } from \"./mediaconnection\";\nimport { DataConnection } from \"./dataconnection\";\nimport {\n  ConnectionType,\n  PeerErrorType,\n  PeerEventType,\n  SocketEventType,\n  ServerMessageType\n} from \"./enums\";\nimport { BaseConnection } from \"./baseconnection\";\nimport { ServerMessage } from \"./servermessage\";\nimport { API } from \"./api\";\nimport { PeerConnectOption, PeerJSOption } from \"..\";\n\nclass PeerOptions implements PeerJSOption {\n  debug?: LogLevel; // 1: Errors, 2: Warnings, 3: All logs\n  host?: string;\n  port?: number;\n  path?: string;\n  key?: string;\n  token?: string;\n  config?: any;\n  secure?: boolean;\n  pingInterval?: number;\n  logFunction?: (logLevel: LogLevel, ...rest: any[]) => void;\n}\n\n/**\n * A peer who can initiate connections with other peers.\n */\nexport class Peer extends EventEmitter {\n  private static readonly DEFAULT_KEY = \"peerjs\";\n\n  private readonly _options: PeerOptions;\n  private readonly _api: API;\n  private readonly _socket: Socket;\n\n  private _id: string | null = null;\n  private _lastServerId: string | null = null;\n\n  // States.\n  private _destroyed = false; // Connections have been killed\n  private _disconnected = false; // Connection to PeerServer killed but P2P connections still active\n  private _open = false; // Sockets and such are not yet open.\n  private readonly _connections: Map<string, BaseConnection[]> = new Map(); // All connections for this peer.\n  private readonly _lostMessages: Map<string, ServerMessage[]> = new Map(); // src => [list of messages]\n\n  get id() {\n    return this._id;\n  }\n\n  get options() {\n    return this._options;\n  }\n\n  get open() {\n    return this._open;\n  }\n\n  get socket() {\n    return this._socket;\n  }\n\n  /**\n   * @deprecated \n   * Return type will change from Object to Map<string,[]> \n   */\n  get connections(): Object {\n    const plainConnections = Object.create(null);\n\n    for (let [k, v] of this._connections) {\n      plainConnections[k] = v;\n    }\n\n    return plainConnections;\n  }\n\n  get destroyed() {\n    return this._destroyed;\n  }\n  get disconnected() {\n    return this._disconnected;\n  }\n\n  constructor(id?: string | PeerOptions, options?: PeerOptions) {\n    super();\n\n    let userId: string | undefined;\n\n    // Deal with overloading\n    if (id && id.constructor == Object) {\n      options = id as PeerOptions;\n    } else if (id) {\n      userId = id.toString();\n    }\n\n    // Configurize options\n    options = {\n      debug: 0, // 1: Errors, 2: Warnings, 3: All logs\n      host: util.CLOUD_HOST,\n      port: util.CLOUD_PORT,\n      path: \"/\",\n      key: Peer.DEFAULT_KEY,\n      token: util.randomToken(),\n      config: util.defaultConfig,\n      ...options\n    };\n    this._options = options;\n\n    // Detect relative URL host.\n    if (this._options.host === \"/\") {\n      this._options.host = window.location.hostname;\n    }\n\n    // Set path correctly.\n    if (this._options.path) {\n      if (this._options.path[0] !== \"/\") {\n        this._options.path = \"/\" + this._options.path;\n      }\n      if (this._options.path[this._options.path.length - 1] !== \"/\") {\n        this._options.path += \"/\";\n      }\n    }\n\n    // Set whether we use SSL to same as current host\n    if (this._options.secure === undefined && this._options.host !== util.CLOUD_HOST) {\n      this._options.secure = util.isSecure();\n    } else if (this._options.host == util.CLOUD_HOST) {\n      this._options.secure = true;\n    }\n    // Set a custom log function if present\n    if (this._options.logFunction) {\n      logger.setLogFunction(this._options.logFunction);\n    }\n\n    logger.logLevel = this._options.debug || 0;\n\n    this._api = new API(options);\n    this._socket = this._createServerConnection();\n\n    // Sanity checks\n    // Ensure WebRTC supported\n    if (!util.supports.audioVideo && !util.supports.data) {\n      this._delayedAbort(\n        PeerErrorType.BrowserIncompatible,\n        \"The current browser does not support WebRTC\"\n      );\n      return;\n    }\n\n    // Ensure alphanumeric id\n    if (!!userId && !util.validateId(userId)) {\n      this._delayedAbort(PeerErrorType.InvalidID, `ID \"${userId}\" is invalid`);\n      return;\n    }\n\n    if (userId) {\n      this._initialize(userId);\n    } else {\n      this._api.retrieveId()\n        .then(id => this._initialize(id))\n        .catch(error => this._abort(PeerErrorType.ServerError, error));\n    }\n  }\n\n  private _createServerConnection(): Socket {\n    const socket = new Socket(\n      this._options.secure,\n      this._options.host!,\n      this._options.port!,\n      this._options.path!,\n      this._options.key!,\n      this._options.pingInterval\n    );\n\n    socket.on(SocketEventType.Message, (data: ServerMessage) => {\n      this._handleMessage(data);\n    });\n\n    socket.on(SocketEventType.Error, (error: string) => {\n      this._abort(PeerErrorType.SocketError, error);\n    });\n\n    socket.on(SocketEventType.Disconnected, () => {\n      if (this.disconnected) {\n        return;\n      }\n\n      this.emitError(PeerErrorType.Network, \"Lost connection to server.\");\n      this.disconnect();\n    });\n\n    socket.on(SocketEventType.Close, () => {\n      if (this.disconnected) {\n        return;\n      }\n\n      this._abort(PeerErrorType.SocketClosed, \"Underlying socket is already closed.\");\n    });\n\n    return socket;\n  }\n\n  /** Initialize a connection with the server. */\n  private _initialize(id: string): void {\n    this._id = id;\n    this.socket.start(id, this._options.token!);\n  }\n\n  /** Handles messages from the server. */\n  private _handleMessage(message: ServerMessage): void {\n    const type = message.type;\n    const payload = message.payload;\n    const peerId = message.src;\n\n    switch (type) {\n      case ServerMessageType.Open: // The connection to the server is open.\n        this._lastServerId = this.id;\n        this._open = true;\n        this.emit(PeerEventType.Open, this.id);\n        break;\n      case ServerMessageType.Error: // Server error.\n        this._abort(PeerErrorType.ServerError, payload.msg);\n        break;\n      case ServerMessageType.IdTaken: // The selected ID is taken.\n        this._abort(PeerErrorType.UnavailableID, `ID \"${this.id}\" is taken`);\n        break;\n      case ServerMessageType.InvalidKey: // The given API key cannot be found.\n        this._abort(PeerErrorType.InvalidKey, `API KEY \"${this._options.key}\" is invalid`);\n        break;\n      case ServerMessageType.Leave: // Another peer has closed its connection to this peer.\n        logger.log(`Received leave message from ${peerId}`);\n        this._cleanupPeer(peerId);\n        this._connections.delete(peerId);\n        break;\n      case ServerMessageType.Expire: // The offer sent to a peer has expired without response.\n        this.emitError(PeerErrorType.PeerUnavailable, `Could not connect to peer ${peerId}`);\n        break;\n      case ServerMessageType.Offer: {\n        // we should consider switching this to CALL/CONNECT, but this is the least breaking option.\n        const connectionId = payload.connectionId;\n        let connection = this.getConnection(peerId, connectionId);\n\n        if (connection) {\n          connection.close();\n          logger.warn(`Offer received for existing Connection ID:${connectionId}`);\n        }\n\n        // Create a new connection.\n        if (payload.type === ConnectionType.Media) {\n          connection = new MediaConnection(peerId, this, {\n            connectionId: connectionId,\n            _payload: payload,\n            metadata: payload.metadata\n          });\n          this._addConnection(peerId, connection);\n          this.emit(PeerEventType.Call, connection);\n        } else if (payload.type === ConnectionType.Data) {\n          connection = new DataConnection(peerId, this, {\n            connectionId: connectionId,\n            _payload: payload,\n            metadata: payload.metadata,\n            label: payload.label,\n            serialization: payload.serialization,\n            reliable: payload.reliable\n          });\n          this._addConnection(peerId, connection);\n          this.emit(PeerEventType.Connection, connection);\n        } else {\n          logger.warn(`Received malformed connection type:${payload.type}`);\n          return;\n        }\n\n        // Find messages.\n        const messages = this._getMessages(connectionId);\n        for (let message of messages) {\n          connection.handleMessage(message);\n        }\n\n        break;\n      }\n      default: {\n        if (!payload) {\n          logger.warn(`You received a malformed message from ${peerId} of type ${type}`);\n          return;\n        }\n\n        const connectionId = payload.connectionId;\n        const connection = this.getConnection(peerId, connectionId);\n\n        if (connection && connection.peerConnection) {\n          // Pass it on.\n          connection.handleMessage(message);\n        } else if (connectionId) {\n          // Store for possible later use\n          this._storeMessage(connectionId, message);\n        } else {\n          logger.warn(\"You received an unrecognized message:\", message);\n        }\n        break;\n      }\n    }\n  }\n\n  /** Stores messages without a set up connection, to be claimed later. */\n  private _storeMessage(connectionId: string, message: ServerMessage): void {\n    if (!this._lostMessages.has(connectionId)) {\n      this._lostMessages.set(connectionId, []);\n    }\n\n    this._lostMessages.get(connectionId).push(message);\n  }\n\n  /** Retrieve messages from lost message store */\n  //TODO Change it to private\n  public _getMessages(connectionId: string): ServerMessage[] {\n    const messages = this._lostMessages.get(connectionId);\n\n    if (messages) {\n      this._lostMessages.delete(connectionId);\n      return messages;\n    }\n\n    return [];\n  }\n\n  /**\n   * Returns a DataConnection to the specified peer. See documentation for a\n   * complete list of options.\n   */\n  connect(peer: string, options: PeerConnectOption = {}): DataConnection {\n    if (this.disconnected) {\n      logger.warn(\n        \"You cannot connect to a new Peer because you called \" +\n        \".disconnect() on this Peer and ended your connection with the \" +\n        \"server. You can create a new Peer to reconnect, or call reconnect \" +\n        \"on this peer if you believe its ID to still be available.\"\n      );\n      this.emitError(\n        PeerErrorType.Disconnected,\n        \"Cannot connect to new Peer after disconnecting from server.\"\n      );\n      return;\n    }\n\n    const dataConnection = new DataConnection(peer, this, options);\n    this._addConnection(peer, dataConnection);\n    return dataConnection;\n  }\n\n  /**\n   * Returns a MediaConnection to the specified peer. See documentation for a\n   * complete list of options.\n   */\n  call(peer: string, stream: MediaStream, options: any = {}): MediaConnection {\n    if (this.disconnected) {\n      logger.warn(\n        \"You cannot connect to a new Peer because you called \" +\n        \".disconnect() on this Peer and ended your connection with the \" +\n        \"server. You can create a new Peer to reconnect.\"\n      );\n      this.emitError(\n        PeerErrorType.Disconnected,\n        \"Cannot connect to new Peer after disconnecting from server.\"\n      );\n      return;\n    }\n\n    if (!stream) {\n      logger.error(\n        \"To call a peer, you must provide a stream from your browser's `getUserMedia`.\"\n      );\n      return;\n    }\n\n    options._stream = stream;\n\n    const mediaConnection = new MediaConnection(peer, this, options);\n    this._addConnection(peer, mediaConnection);\n    return mediaConnection;\n  }\n\n  /** Add a data/media connection to this peer. */\n  private _addConnection(peerId: string, connection: BaseConnection): void {\n    logger.log(`add connection ${connection.type}:${connection.connectionId} to peerId:${peerId}`);\n\n    if (!this._connections.has(peerId)) {\n      this._connections.set(peerId, []);\n    }\n    this._connections.get(peerId).push(connection);\n  }\n\n  //TODO should be private\n  _removeConnection(connection: BaseConnection): void {\n    const connections = this._connections.get(connection.peer);\n\n    if (connections) {\n      const index = connections.indexOf(connection);\n\n      if (index !== -1) {\n        connections.splice(index, 1);\n      }\n    }\n\n    //remove from lost messages\n    this._lostMessages.delete(connection.connectionId);\n  }\n\n  /** Retrieve a data/media connection for this peer. */\n  getConnection(peerId: string, connectionId: string): null | BaseConnection {\n    const connections = this._connections.get(peerId);\n    if (!connections) {\n      return null;\n    }\n\n    for (let connection of connections) {\n      if (connection.connectionId === connectionId) {\n        return connection;\n      }\n    }\n\n    return null;\n  }\n\n  private _delayedAbort(type: PeerErrorType, message: string | Error): void {\n    setTimeout(() => {\n      this._abort(type, message);\n    }, 0);\n  }\n\n  /**\n   * Emits an error message and destroys the Peer.\n   * The Peer is not destroyed if it's in a disconnected state, in which case\n   * it retains its disconnected state and its existing connections.\n   */\n  private _abort(type: PeerErrorType, message: string | Error): void {\n    logger.error(\"Aborting!\");\n\n    this.emitError(type, message);\n\n    if (!this._lastServerId) {\n      this.destroy();\n    } else {\n      this.disconnect();\n    }\n  }\n\n  /** Emits a typed error message. */\n  emitError(type: PeerErrorType, err: string | Error): void {\n    logger.error(\"Error:\", err);\n\n    let error: Error & { type?: PeerErrorType };\n\n    if (typeof err === \"string\") {\n      error = new Error(err);\n    } else {\n      error = err as Error;\n    }\n\n    error.type = type;\n\n    this.emit(PeerEventType.Error, error);\n  }\n\n  /**\n   * Destroys the Peer: closes all active connections as well as the connection\n   *  to the server.\n   * Warning: The peer can no longer create or accept connections after being\n   *  destroyed.\n   */\n  destroy(): void {\n    if (this.destroyed) {\n      return;\n    }\n\n    logger.log(`Destroy peer with ID:${this.id}`);\n\n    this.disconnect();\n    this._cleanup();\n\n    this._destroyed = true;\n\n    this.emit(PeerEventType.Close);\n  }\n\n  /** Disconnects every connection on this peer. */\n  private _cleanup(): void {\n    for (let peerId of this._connections.keys()) {\n      this._cleanupPeer(peerId);\n      this._connections.delete(peerId);\n    }\n\n    this.socket.removeAllListeners();\n  }\n\n  /** Closes all connections to this peer. */\n  private _cleanupPeer(peerId: string): void {\n    const connections = this._connections.get(peerId);\n\n    if (!connections) return;\n\n    for (let connection of connections) {\n      connection.close();\n    }\n  }\n\n  /**\n   * Disconnects the Peer's connection to the PeerServer. Does not close any\n   *  active connections.\n   * Warning: The peer can no longer create or accept connections after being\n   *  disconnected. It also cannot reconnect to the server.\n   */\n  disconnect(): void {\n    if (this.disconnected) {\n      return;\n    }\n\n    const currentId = this.id;\n\n    logger.log(`Disconnect peer with ID:${currentId}`);\n\n    this._disconnected = true;\n    this._open = false;\n\n    this.socket.close();\n\n    this._lastServerId = currentId;\n    this._id = null;\n\n    this.emit(PeerEventType.Disconnected, currentId);\n  }\n\n  /** Attempts to reconnect with the same ID. */\n  reconnect(): void {\n    if (this.disconnected && !this.destroyed) {\n      logger.log(`Attempting reconnection to server with ID ${this._lastServerId}`);\n      this._disconnected = false;\n      this._initialize(this._lastServerId!);\n    } else if (this.destroyed) {\n      throw new Error(\"This peer cannot reconnect to the server. It has already been destroyed.\");\n    } else if (!this.disconnected && !this.open) {\n      // Do nothing. We're still connecting the first time.\n      logger.error(\"In a hurry? We're still trying to make the initial connection!\");\n    } else {\n      throw new Error(`Peer ${this.id} cannot reconnect because it is not disconnected from the server!`);\n    }\n  }\n\n  /**\n   * Get a list of available peer IDs. If you're running your own server, you'll\n   * want to set allow_discovery: true in the PeerServer options. If you're using\n   * the cloud server, email team@peerjs.com to get the functionality enabled for\n   * your key.\n   */\n  listAllPeers(cb = (_: any[]) => { }): void {\n    this._api.listAllPeers()\n      .then(peers => cb(peers))\n      .catch(error => this._abort(PeerErrorType.ServerError, error));\n  }\n}\n","import { util } from \"./util\";\nimport { Peer } from \"./peer\";\n\nexport const peerjs = {\n  Peer,\n  util,\n};\n\nexport default Peer;\n\n(<any>window).peerjs = peerjs;\n/** @deprecated Should use peerjs namespace */\n(<any>window).Peer = Peer;\n"],"names":["Supports","this","includes","navigator","platform","isWebRTCSupported","RTCPeerConnection","isBrowserSupported","browser","getBrowser","version","getVersion","supportedBrowsers","minChromeVersion","minFirefoxVersion","isIOS","minSafariVersion","webRTCAdapter","browserDetails","isUnifiedPlanSupported","tempPc","window","RTCRtpTransceiver","prototype","supported","addTransceiver","e","close","toString","DEFAULT_CONFIG","iceServers","urls","username","credential","sdpSemantics","util","Chrome","chrome","pc","webRTC","audioVideo","data","binaryBlob","reliable","dc","createDataChannel","ordered","binaryType","BinaryPack","noop","validateId","id","test","chunk","blob","chunks","size","total","Math","ceil","chunkedMTU","index","start","end","min","b","slice","push","__peerData","_dataCount","n","blobToArrayBuffer","cb","fr","FileReader","onload","evt","target","result","readAsArrayBuffer","binaryStringToArrayBuffer","binary","byteArray","Uint8Array","length","i","charCodeAt","buffer","randomToken","random","substr","isSecure","location","protocol","LogLevel","LOG_PREFIX","ConnectionEventType","ConnectionType","PeerEventType","PeerErrorType","SerializationType","SocketEventType","ServerMessageType","Disabled","log","_logLevel","All","_print","warn","Warnings","error","Errors","setLogFunction","fn","logLevel","copy","Error","name","message","console","Socket","secure","host","port","path","key","pingInterval","_this","_baseUrl","token","_id","_socket","_disconnected","WebSocket","onmessage","event","JSON","parse","logger","_this2","emit","Message","onclose","_cleanup","Disconnected","onopen","_sendQueuedMessages","_scheduleHeartbeat","_wsPingTimer","setTimeout","_this3","_sendHeartbeat","_wsOpen","stringify","type","Heartbeat","send","readyState","copiedQueue","_messagesQueue","undefined","clearTimeout","EventEmitter","Negotiator","connection","startConnection","options","peerConnection","_startPeerConnection","Media","_stream","_addTracksToConnection","originator","Data","dataConnection","dataChannel","label","initialize","_makeOffer","handleSDP","sdp","provider","config","_setupListeners","peerId","peer","connectionId","connectionType","onicecandidate","candidate","socket","Candidate","payload","dst","oniceconnectionstatechange","iceConnectionState","IceStateChanged","ondatachannel","channel","getConnection","ontrack","stream","streams","_addStreamToMediaConnection","cleanup","dataChannelNotClosed","signalingState","createOffer","constraints","offer","sdpTransform","setLocalDescription","metadata","serialization","Offer","err","emitError","WebRTC","err_1","_makeAnswer","_this5","createAnswer","answer","Answer","RTCSessionDescription","_this7","self","setRemoteDescription","handleCandidate","ice","sdpMLineIndex","sdpMid","_this9","addIceCandidate","RTCIceCandidate","addTrack","getTracks","forEach","track","mediaConnection","addStream","BaseConnection","_createClass","_open","MediaConnection","_localStream","ID_PREFIX","_negotiator","remoteStream","_remoteStream","_BaseConnection","Stream","handleMessage","_payload","_getMessages","_removeConnection","open","Close","EncodingQueue","fileReader","_processing","doNextTask","onerror","destroy","enque","queue","processing","abort","_queue","shift","DataConnection","Binary","_encodingQueue","on","ab","_bufferedSend","_dc","_configureDataChannel","supports","Open","_handleDataMessage","datatype","constructor","deserializedData","BinaryUTF8","Blob","unpackedData","unpack","ArrayBuffer","String","_handleChunk","chunkInfo","_chunkedData","count","_buffer","_bufferSize","removeAllListeners","chunked","pack","_sendChunks","msg","_buffering","_trySend","bufferedAmount","MAX_BUFFERED_AMOUNT","_this4","_tryBuffer","blobs","API","_options","_buildUrl","method","Date","getTime","retrieveId","url","fetch","response","status","text","pathError","CLOUD_HOST","listAllPeers","json","Peer","userId","Map","Object","debug","CLOUD_PORT","DEFAULT_KEY","defaultConfig","hostname","logFunction","_api","_createServerConnection","_delayedAbort","InvalidID","_initialize","then","_abort","ServerError","BrowserIncompatible","_handleMessage","SocketError","disconnected","Network","disconnect","SocketClosed","src","_lastServerId","IdTaken","UnavailableID","InvalidKey","Leave","_cleanupPeer","_connections","Expire","PeerUnavailable","_addConnection","Call","Connection","_storeMessage","_lostMessages","has","set","get","messages","connect","call","connections","indexOf","splice","destroyed","_destroyed","keys","currentId","reconnect","_","peers","plainConnections","create","peerjs"],"mappings":"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"}